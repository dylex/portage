diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000000..42193c7bd7
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,20 @@
+Makefile
+Makefile.in
+/aclocal.m4
+/autom4te.cache/
+/compile
+/config.cache
+/config.guess
+/config.h.in
+/config.log
+/config.status
+/config.sub
+/configure
+/depcomp
+/install-sh
+/intltool-*
+/ltmain.sh
+/missing
+/po/Makefile.in.in
+/po/Makefile.in.in.bak
+/test-driver
diff --git a/Makefile.am b/Makefile.am
index af108f2f34..338d146c47 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -1,4 +1,4 @@
-EXTRA_DIST = \
+EXTRA_DIST = config.rpath  \
 		COPYRIGHT \
 		ChangeLog.API \
 		ChangeLog.win32 \
@@ -145,3 +145,4 @@ DISTCLEANFILES= intltool-extract intltool-merge intltool-update \
 # https://bugs.launchpad.net/intltool/+bug/1712194
 DISTCLEANFILES += po/.intltool-merge-cache.lock
 
+ACLOCAL_AMFLAGS = -I m4
diff --git a/finch/Makefile.am b/finch/Makefile.am
index 9933f6e65c..f0cc84a762 100644
--- a/finch/Makefile.am
+++ b/finch/Makefile.am
@@ -25,6 +25,7 @@ finch_SOURCES = \
 	gntft.c \
 	finch.c \
 	gntidle.c \
+	gntimhtml.c \
 	gntlog.c \
 	gntmedia.c \
 	gntnotify.c \
@@ -47,6 +48,7 @@ finch_headers = \
 	gntft.h \
 	finch.h \
 	gntidle.h \
+	gntimhtml.h \
 	gntlog.h \
 	gntmedia.h \
 	gntnotify.h \
diff --git a/finch/gntblist.c b/finch/gntblist.c
index b72c8ee92a..7ed0e2a4d3 100644
--- a/finch/gntblist.c
+++ b/finch/gntblist.c
@@ -1235,6 +1235,11 @@ create_chat_menu(GntMenu *menu, PurpleChat *chat)
 	g_signal_connect_swapped(G_OBJECT(menu), "destroy",
 			G_CALLBACK(purple_menu_action_free), action);
 
+	/* Protocol actions */
+	append_proto_menu(menu,
+			purple_account_get_connection(purple_chat_get_account(chat)),
+			(PurpleBlistNode*)chat);
+
 	add_custom_action(menu, _("Edit Settings"), (PurpleCallback)chat_components_edit, chat);
 }
 
@@ -1324,6 +1329,13 @@ toggle_show_offline(GntMenuItem *item, gpointer buddy)
 		node_update(purple_get_blist(), buddy);
 }
 
+static void
+toggle_log(GntMenuItem *item, gpointer buddy)
+{
+	purple_blist_node_set_bool(buddy, "log",
+			!purple_blist_node_get_bool(buddy, "log"));
+}
+
 static void
 create_buddy_menu(GntMenu *menu, PurpleBuddy *buddy)
 {
@@ -1364,6 +1376,11 @@ create_buddy_menu(GntMenu *menu, PurpleBuddy *buddy)
 	gnt_menuitem_set_callback(item, toggle_show_offline, buddy);
 	gnt_menu_add_item(menu, item);
 
+	item = gnt_menuitem_check_new(_("Always log"));
+	gnt_menuitem_check_set_checked(GNT_MENU_ITEM_CHECK(item), purple_blist_node_get_bool((PurpleBlistNode*)buddy, "log"));
+	gnt_menuitem_set_callback(item, toggle_log, buddy);
+	gnt_menu_add_item(menu, item);
+
 	/* Protocol actions */
 	append_proto_menu(menu,
 			purple_account_get_connection(purple_buddy_get_account(buddy)),
@@ -2767,6 +2784,55 @@ block_select(GntMenuItem *item, gpointer n)
 						NULL);
 }
 
+static void
+privacy_select_cb(gpointer data, PurpleRequestFields *fields)
+{
+	PurpleAccount *account = purple_request_fields_get_account(fields, "account");
+	if (account) {
+		account->perm_deny = purple_request_fields_get_choice(fields, "privacy");
+		serv_set_permit_deny(purple_account_get_connection(account));
+	}
+}
+
+static void
+privacy_select(GntMenuItem *item, gpointer n)
+{
+	PurpleRequestFields *fields;
+	PurpleRequestFieldGroup *group;
+	PurpleRequestField *field;
+
+	fields = purple_request_fields_new();
+
+	group = purple_request_field_group_new(NULL);
+	purple_request_fields_add_group(fields, group);
+
+	field = purple_request_field_account_new("account", _("Account"), NULL);
+	purple_request_field_set_type_hint(field, "account");
+	purple_request_field_set_visible(field,
+		(purple_connections_get_all() != NULL &&
+		 purple_connections_get_all()->next != NULL));
+	purple_request_field_set_required(field, TRUE);
+	purple_request_field_group_add_field(group, field);
+
+	field = purple_request_field_choice_new("privacy", _("Privacy"), 1);
+	/* these are assumed to be in PurplePrivacyType order */
+	purple_request_field_choice_add(field, _("Allow all"));
+	purple_request_field_choice_add(field, _("Allow only buddy list"));
+	purple_request_field_choice_add(field, _("Allow only unblocked"));
+	purple_request_field_choice_add(field, _("Deny all"));
+	purple_request_field_choice_add(field, _("Deny only blocked"));
+	purple_request_field_group_add_field(group, field);
+
+	purple_request_fields(purple_get_blist(), _("Set"),
+						NULL,
+						_("Select which users may contact you on the specified account."),
+						fields,
+						_("OK"), G_CALLBACK(privacy_select_cb),
+						_("Cancel"), NULL,
+						NULL, NULL, NULL,
+						NULL);
+}
+
 /* send_im_select* -- Xerox */
 static void
 send_im_select_cb(gpointer data, PurpleRequestFields *fields)
@@ -3015,6 +3081,11 @@ create_menu(void)
 	gnt_menu_add_item(GNT_MENU(sub), item);
 	gnt_menuitem_set_callback(GNT_MENU_ITEM(item), block_select, NULL);
 
+	item = gnt_menuitem_new(_("Privacy..."));
+	gnt_menuitem_set_id(GNT_MENU_ITEM(item), "privacy");
+	gnt_menu_add_item(GNT_MENU(sub), item);
+	gnt_menuitem_set_callback(GNT_MENU_ITEM(item), privacy_select, NULL);
+
 	item = gnt_menuitem_new(_("Join Chat..."));
 	gnt_menuitem_set_id(GNT_MENU_ITEM(item), "join-chat");
 	gnt_menu_add_item(GNT_MENU(sub), item);
diff --git a/finch/gntconv.c b/finch/gntconv.c
index 24d1d45424..81a9c2775c 100644
--- a/finch/gntconv.c
+++ b/finch/gntconv.c
@@ -44,6 +44,7 @@
 #include "gntrequest.h"
 #include "gntsound.h"
 #include "gntstatus.h"
+#include "gntimhtml.h"
 
 #include "gnt.h"
 #include "gntbox.h"
@@ -150,7 +151,7 @@ entry_key_pressed(GntWidget *w, FinchConv *ggconv)
 		char *error = NULL, *escape;
 
 		escape = g_markup_escape_text(cmdline, -1);
-		status = purple_cmd_do_command(conv, cmdline, escape, &error);
+		status = purple_cmd_do_command(conv, escape, cmdline, &error);
 		g_free(escape);
 
 		switch (status)
@@ -488,6 +489,16 @@ toggle_sound_cb(GntMenuItem *item, gpointer ggconv)
 		purple_blist_node_set_bool(node, "gnt-mute-sound", !!(fc->flags & FINCH_CONV_NO_SOUND));
 }
 
+static void
+toggle_userlist_cb(GntMenuItem *item, gpointer ggconv)
+{
+	FinchConv *fc = ggconv;
+	PurpleBlistNode *node = get_conversation_blist_node(fc->active_conv);
+	fc->flags ^= FINCH_CONV_NO_USERLIST;
+	if (node)
+		purple_blist_node_set_bool(node, "gnt-no-userlist", !!(fc->flags & FINCH_CONV_NO_USERLIST));
+}
+
 static void
 send_to_cb(GntMenuItem *m, gpointer n)
 {
@@ -536,6 +547,41 @@ view_log_cb(GntMenuItem *n, gpointer ggc)
 	finch_log_show(type, name, account);
 }
 
+static void
+set_blist_node_alertcount(PurpleBlistNode *node, PurpleRequestFields *fields)
+{
+	int alert = purple_request_fields_get_integer(fields, "alert");
+	purple_blist_node_set_int(node, "alertcount", alert);
+}
+
+static void
+set_alertcount_cb(GntMenuItem *n, gpointer ggc) {
+	FinchConv *fc = ggc;
+	PurpleConversation *conv = fc->active_conv;
+	PurpleBlistNode *node = NULL;
+	switch (conv->type) {
+		case PURPLE_CONV_TYPE_IM:
+			node = PURPLE_BLIST_NODE(find_buddy_for_conversation(conv));
+			break;
+		case PURPLE_CONV_TYPE_CHAT:
+			node = PURPLE_BLIST_NODE(find_chat_for_conversation(conv));
+			break;
+	}
+	g_return_if_fail(node);
+	int alert = purple_blist_node_get_int(node, "alertcount");
+	PurpleRequestFields *fields = purple_request_fields_new();
+	PurpleRequestFieldGroup *group = purple_request_field_group_new(NULL);
+	purple_request_fields_add_group(fields, group);
+	PurpleRequestField *field = purple_request_field_int_new("alert", "Alert", alert);
+	purple_request_field_group_add_field(group, field);
+	purple_request_fields(node, "Alert count", "Enter alert count color value", NULL,
+			fields,
+			"Set", G_CALLBACK(set_blist_node_alertcount),
+			"Cancel", NULL,
+			NULL, NULL, fc->active_conv,
+			node);
+}
+
 static void
 generate_send_to_menu(FinchConv *ggc)
 {
@@ -665,6 +711,18 @@ gg_create_menu(FinchConv *ggc)
 			!(ggc->flags & FINCH_CONV_NO_SOUND));
 	gnt_menu_add_item(GNT_MENU(sub), item);
 	gnt_menuitem_set_callback(item, toggle_sound_cb, ggc);
+
+	if (purple_conversation_get_type(ggc->active_conv) == PURPLE_CONV_TYPE_CHAT) {
+		item = gnt_menuitem_check_new(_("Enable User List"));
+		gnt_menuitem_check_set_checked(GNT_MENU_ITEM_CHECK(item),
+				!(ggc->flags & FINCH_CONV_NO_USERLIST));
+		gnt_menu_add_item(GNT_MENU(sub), item);
+		gnt_menuitem_set_callback(item, toggle_userlist_cb, ggc);
+	}
+
+	item = gnt_menuitem_new(_("Set alertcount..."));
+	gnt_menu_add_item(GNT_MENU(sub), item);
+	gnt_menuitem_set_callback(item, set_alertcount_cb, ggc);
 }
 
 static void
@@ -868,6 +926,9 @@ finch_create_conversation(PurpleConversation *conv)
 			!finch_sound_is_enabled())
 		ggc->flags |= FINCH_CONV_NO_SOUND;
 
+	if (convnode && purple_blist_node_get_bool(convnode, "gnt-no-userlist"))
+		ggc->flags |= FINCH_CONV_NO_USERLIST;
+
 	gg_create_menu(ggc);
 	gg_setup_commands(ggc, FALSE);
 
@@ -906,7 +967,7 @@ finch_write_common(PurpleConversation *conv, const char *who, const char *messag
 		PurpleMessageFlags flags, time_t mtime)
 {
 	FinchConv *ggconv = FINCH_GET_DATA(conv);
-	char *strip, *newline;
+	char *strip;
 	GntTextFormatFlags fl = 0;
 	int pos;
 
@@ -933,7 +994,7 @@ finch_write_common(PurpleConversation *conv, const char *who, const char *messag
 		if (!mtime)
 			time(&mtime);
 		gnt_text_view_append_text_with_flags(GNT_TEXT_VIEW(ggconv->tv),
-					purple_utf8_strftime("(%H:%M:%S)", localtime(&mtime)), gnt_color_pair(color_timestamp));
+					purple_utf8_strftime(purple_prefs_get_string("/finch/conversations/timestamp_fmt"), localtime(&mtime)), gnt_color_pair(color_timestamp));
 	}
 
 	gnt_text_view_append_text_with_flags(GNT_TEXT_VIEW(ggconv->tv), " ", GNT_TEXT_FLAG_NORMAL);
@@ -976,14 +1037,7 @@ finch_write_common(PurpleConversation *conv, const char *who, const char *messag
 	if (flags & PURPLE_MESSAGE_ERROR)
 		fl |= GNT_TEXT_FLAG_BOLD;
 
-	/* XXX: Remove this workaround when textview can parse messages. */
-	newline = purple_strdup_withhtml(message);
-	strip = purple_markup_strip_html(newline);
-	gnt_text_view_append_text_with_flags(GNT_TEXT_VIEW(ggconv->tv),
-				strip, fl);
-
-	g_free(newline);
-	g_free(strip);
+	gnt_imhtml_append_markup(GNT_TEXT_VIEW(ggconv->tv), message, fl);
 
 	if (purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_IM &&
 			purple_conv_im_get_typing_state(PURPLE_CONV_IM(conv)) == PURPLE_TYPING) {
@@ -1072,7 +1126,7 @@ finch_chat_add_users(PurpleConversation *conv, GList *users, gboolean new_arriva
 	FinchConv *ggc = FINCH_GET_DATA(conv);
 	GntEntry *entry = GNT_ENTRY(ggc->entry);
 
-	if (!new_arrivals)
+	if (!new_arrivals && !(ggc->flags & FINCH_CONV_NO_USERLIST))
 	{
 		/* Print the list of users in the room */
 		GString *string = g_string_new(NULL);
diff --git a/finch/gntconv.h b/finch/gntconv.h
index b188469bf5..eedbcceed4 100644
--- a/finch/gntconv.h
+++ b/finch/gntconv.h
@@ -47,6 +47,7 @@ typedef struct _FinchConvIm FinchConvIm;
 typedef enum
 {
 	FINCH_CONV_NO_SOUND     = 1 << 0,
+	FINCH_CONV_NO_USERLIST  = 1 << 1,
 } FinchConversationFlag;
 
 struct _FinchConv
diff --git a/finch/gntimhtml.c b/finch/gntimhtml.c
new file mode 100644
index 0000000000..56dc007580
--- /dev/null
+++ b/finch/gntimhtml.c
@@ -0,0 +1,477 @@
+/*
+* @file gntimhtml.c GNT IMHtml
+* @ingroup finch
+*/
+
+/* finch
+*
+* Finch is the legal property of its developers, whose names are too numerous
+* to list here.  Please refer to the COPYRIGHT file distributed with this
+* source distribution.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02111-1301  USA
+*/
+
+#include "gnt.h"
+#include "gnttextview.h"
+#include "gntimhtml.h"
+
+#include "util.h"
+#include <string.h>
+#include <ctype.h>
+
+/******************************************************************************
+* GntIMHtml API
+*****************************************************************************/
+
+/* This could be a separate class, but at present there's no need.
+* Most of the following was copied from pidgin/gtkimhtml */
+
+#define VALID_TAG(x)	if (!g_ascii_strncasecmp (string, x ">", strlen (x ">"))) {	\
+			*tag = g_strndup (string, strlen (x));		\
+			*len = strlen (x) + 1;				\
+			return TRUE;					\
+		}							\
+		(*type)++
+
+#define VALID_OPT_TAG(x) if (!g_ascii_strncasecmp (string, x " ", strlen (x " "))) {	\
+				const gchar *c = string + strlen (x " ");	\
+				gchar e = '"';					\
+				gboolean quote = FALSE;				\
+				while (*c) {					\
+					if (*c == '"' || *c == '\'') {		\
+						if (quote && (*c == e))		\
+							quote = !quote;		\
+						else if (!quote) {		\
+							quote = !quote;		\
+							e = *c;			\
+						}				\
+					} else if (!quote && (*c == '>'))	\
+						break;				\
+					c++;					\
+				}						\
+				if (*c) {					\
+					*tag = g_strndup (string, c - string);	\
+					*len = c - string + 1;			\
+					return TRUE;				\
+				}						\
+			}							\
+			(*type)++
+
+static gboolean
+gnt_imhtml_is_tag (const gchar *string,
+	   gchar      **tag,
+	   gint        *len,
+	   gint        *type)
+{
+	char *close;
+	*type = 1;
+
+	if (!(close = strchr (string, '>')))
+		return FALSE;
+
+	VALID_TAG ("B");
+	VALID_TAG ("BOLD");
+	VALID_TAG ("/B");
+	VALID_TAG ("/BOLD");
+	VALID_TAG ("I");
+	VALID_TAG ("ITALIC");
+	VALID_TAG ("/I");
+	VALID_TAG ("/ITALIC");
+	VALID_TAG ("U");
+	VALID_TAG ("UNDERLINE");
+	VALID_TAG ("/U");
+	VALID_TAG ("/UNDERLINE");
+	VALID_TAG ("S");
+	VALID_TAG ("STRIKE");
+	VALID_TAG ("/S");
+	VALID_TAG ("/STRIKE");
+	VALID_TAG ("SUB");
+	VALID_TAG ("/SUB");
+	VALID_TAG ("SUP");
+	VALID_TAG ("/SUP");
+	VALID_TAG ("PRE");
+	VALID_TAG ("/PRE");
+	VALID_TAG ("TITLE");
+	VALID_TAG ("/TITLE");
+	VALID_TAG ("BR");
+	VALID_TAG ("HR");
+	VALID_TAG ("/FONT");
+	VALID_TAG ("/A");
+	VALID_TAG ("P");
+	VALID_TAG ("/P");
+	VALID_TAG ("H3");
+	VALID_TAG ("/H3");
+	VALID_TAG ("HTML");
+	VALID_TAG ("/HTML");
+	VALID_TAG ("BODY");
+	VALID_TAG ("/BODY");
+	VALID_TAG ("FONT");
+	VALID_TAG ("HEAD");
+	VALID_TAG ("/HEAD");
+	VALID_TAG ("BINARY");
+	VALID_TAG ("/BINARY");
+
+	VALID_OPT_TAG ("HR");
+	VALID_OPT_TAG ("FONT");
+	VALID_OPT_TAG ("BODY");
+	VALID_OPT_TAG ("A");
+	VALID_OPT_TAG ("IMG");
+	VALID_OPT_TAG ("P");
+	VALID_OPT_TAG ("H3");
+	VALID_OPT_TAG ("HTML");
+
+	VALID_TAG ("CITE");
+	VALID_TAG ("/CITE");
+	VALID_TAG ("EM");
+	VALID_TAG ("/EM");
+	VALID_TAG ("STRONG");
+	VALID_TAG ("/STRONG");
+
+	VALID_OPT_TAG ("SPAN");
+	VALID_TAG ("/SPAN");
+	VALID_TAG ("BR/"); /* hack until gtkimhtml handles things better */
+	VALID_TAG ("IMG");
+	VALID_TAG("SPAN");
+	VALID_OPT_TAG("BR");
+
+	if (!g_ascii_strncasecmp(string, "!--", strlen ("!--"))) {
+		gchar *e = strstr (string + strlen("!--"), "-->");
+		if (e) {
+			*len = e - string + strlen ("-->");
+			*tag = g_strndup (string + strlen ("!--"), *len - strlen ("!---->"));
+			return TRUE;
+		}
+	}
+
+	*type = -1;
+	*len = close - string + 1;
+	*tag = g_strndup(string, *len - 1);
+	return TRUE;
+}
+
+static gchar*
+gnt_imhtml_get_html_opt (gchar       *tag,
+		 const gchar *opt)
+{
+	gchar *t = tag;
+	gchar *e, *a;
+	gchar *val;
+	gint len;
+	const gchar *c;
+	GString *ret;
+
+	while (g_ascii_strncasecmp (t, opt, strlen (opt))) {
+		gboolean quote = FALSE;
+		if (*t == '\0') break;
+		while (*t && !((*t == ' ') && !quote)) {
+			if (*t == '\"')
+				quote = ! quote;
+			t++;
+		}
+		while (*t && (*t == ' ')) t++;
+	}
+
+	if (!g_ascii_strncasecmp (t, opt, strlen (opt))) {
+		t += strlen (opt);
+	} else {
+		return NULL;
+	}
+
+	if ((*t == '\"') || (*t == '\'')) {
+		e = a = ++t;
+		while (*e && (*e != *(t - 1))) e++;
+		if  (*e == '\0') {
+			return NULL;
+		} else
+			val = g_strndup(a, e - a);
+	} else {
+		e = a = t;
+		while (*e && !isspace ((gint) *e)) e++;
+		val = g_strndup(a, e - a);
+	}
+
+	ret = g_string_new("");
+	e = val;
+	while(*e) {
+		if((c = purple_markup_unescape_entity(e, &len))) {
+			ret = g_string_append(ret, c);
+			e += len;
+		} else {
+			gunichar uni = g_utf8_get_char(e);
+			ret = g_string_append_unichar(ret, uni);
+			e = g_utf8_next_char(e);
+		}
+	}
+
+	g_free(val);
+
+	return g_string_free(ret, FALSE);
+}
+
+static int gnt_imhtml_fgcolor(const char *color)
+{
+	if (!g_ascii_strcasecmp(color, "red"))
+		return gnt_color_pair(GNT_COLOR_RED);
+	else if (!g_ascii_strcasecmp(color, "green"))
+		return gnt_color_pair(GNT_COLOR_GREEN);
+	else if (!g_ascii_strcasecmp(color, "yellow"))
+		return gnt_color_pair(GNT_COLOR_YELLOW);
+	else if (!g_ascii_strcasecmp(color, "blue"))
+		return gnt_color_pair(GNT_COLOR_BLUE);
+	else if (!g_ascii_strcasecmp(color, "magenta"))
+		return gnt_color_pair(GNT_COLOR_MAGENTA);
+	else if (!g_ascii_strcasecmp(color, "cyan"))
+		return gnt_color_pair(GNT_COLOR_CYAN);
+	else if (!g_ascii_strcasecmp(color, "white"))
+		return gnt_color_pair(GNT_COLOR_WHITE);
+	else if (!g_ascii_strcasecmp(color, "black"))
+		return gnt_color_pair(GNT_COLOR_BLACK);
+	return 0;
+}
+
+void gnt_imhtml_append_markup(GntTextView *view, const char *text, GntTextFormatFlags orig_flags)
+{
+	gchar *ws;
+	gint wpos=0;
+	const gchar *c;
+
+	guint	bold = 0,
+		underline = 0;
+	gchar *href = NULL;
+	gboolean br = FALSE;
+
+	GntTextFormatFlags flags = orig_flags;
+	GSList *fonts = NULL;
+
+	g_return_if_fail (view != NULL);
+	g_return_if_fail (GNT_IS_TEXT_VIEW (view));
+	g_return_if_fail (text != NULL);
+	c = text;
+	ws = g_malloc(strlen(text) + 1);
+	ws[0] = 0;
+
+	#define ADD_TEXT if (wpos) { ws[wpos] = '\0'; gnt_text_view_append_text_with_flags(view, ws, flags); ws[wpos = 0] = '\0'; }
+
+	while (*c)
+	{
+		gchar *tag;
+		gint tlen, type;
+		const gchar *amp;
+		if (*c == '<' && gnt_imhtml_is_tag (c + 1, &tag, &tlen, &type)) {
+				c++;
+				ws[wpos] = '\0';
+				br = FALSE;
+				switch (type)
+				{
+					/* these random numbers are awful */
+					case 1:		/* B */
+					case 2:		/* BOLD */
+					case 54:	/* STRONG */
+					case 52:	/* EM */
+						if (!bold++)
+						{
+							ADD_TEXT;
+							flags |= GNT_TEXT_FLAG_BOLD;
+						}
+						break;
+					case 3:		/* /B */
+					case 4:		/* /BOLD */
+					case 55:	/* /STRONG */
+					case 53:	/* /EM */
+						if (bold && !--bold)
+						{
+							ADD_TEXT;
+							flags &= ~GNT_TEXT_FLAG_BOLD | orig_flags;
+						}
+						break;
+					case 5:		/* I */
+					case 6:		/* ITALIC */
+					case 9:		/* U */
+					case 10:	/* UNDERLINE */
+						ADD_TEXT;
+						underline++;
+						flags ^= GNT_TEXT_FLAG_UNDERLINE;
+						break;
+					case 7:		/* /I */
+					case 8:		/* /ITALIC */
+					case 11:	/* /U */
+					case 12:	/* /UNDERLINE */
+						if (underline)
+						{
+							ADD_TEXT;
+							underline--;
+							flags ^= GNT_TEXT_FLAG_UNDERLINE;
+						}
+						break;
+					case 17:	/* SUB */
+						ws[wpos++] = '_';
+						break;
+					case 19:	/* SUP */
+						ws[wpos++] = '^';
+						break;
+					case 25:	/* BR */
+					case 58:	/* BR/ */
+					case 61:	/* BR (opt) */
+					case 26:        /* HR */
+					case 42:        /* HR (opt) */
+						ws[wpos++] = '\n';
+						br = TRUE;
+						break;
+					case 37:	/* FONT */
+						fonts = g_slist_prepend(fonts, GINT_TO_POINTER(flags));
+						break;
+					case 43:	/* FONT (opt) */
+						fonts = g_slist_prepend(fonts, GINT_TO_POINTER(flags));
+						{
+							gchar *color;
+							color = gnt_imhtml_get_html_opt (tag, "COLOR=");
+
+							if (color)
+							{
+								ADD_TEXT;
+								flags &= ~A_COLOR;
+								flags |= gnt_imhtml_fgcolor(color);
+								g_free(color);
+							}
+						}
+						break;
+					case 27:	/* /FONT */
+						if (fonts)
+						{
+							ADD_TEXT;
+							flags &= ~A_COLOR;
+							flags |= GPOINTER_TO_INT(fonts->data) & A_COLOR;
+							fonts = g_slist_remove (fonts, fonts->data);
+
+						}
+						break;
+					case 45:	/* A (opt) */
+						ADD_TEXT;
+						if (href)
+							g_free(href);
+						href = gnt_imhtml_get_html_opt(tag, "HREF=");
+						flags ^= GNT_TEXT_FLAG_UNDERLINE;
+						break;
+					case 28:        /* /A    */
+						ADD_TEXT;
+						flags ^= GNT_TEXT_FLAG_UNDERLINE;
+						if (href)
+						{
+							// ws[wpos++] = ' ';
+							ws[wpos++] = '[';
+							strcpy(&ws[wpos], href);
+							wpos += strlen(href);
+							ws[wpos++] = ']';
+							g_free(href);
+							href = NULL;
+						}
+						break;
+					case 47:	/* P (opt) */
+					case 48:	/* H3 (opt) */
+					case 49:	/* HTML (opt) */
+					case 50:	/* CITE */
+					case 51:	/* /CITE */
+					case 56:	/* SPAN (opt) */
+						fonts = g_slist_prepend(fonts, GINT_TO_POINTER(flags));
+						{
+							gchar *style, *color = NULL, *textdec = NULL, *weight = NULL;
+							style = gnt_imhtml_get_html_opt (tag, "style=");
+
+							if (style)
+							{
+								color = purple_markup_get_css_property (style, "color");
+								textdec = purple_markup_get_css_property (style, "text-decoration");
+								weight = purple_markup_get_css_property (style, "font-weight");
+							}
+
+							if (color)
+							{
+								ADD_TEXT;
+								flags &= ~A_COLOR;
+								flags |= gnt_imhtml_fgcolor(color);
+								g_free(color);
+							}
+							if (textdec)
+							{
+								if (!g_ascii_strcasecmp(textdec, "underline"))
+								{
+									ADD_TEXT;
+									flags ^= GNT_TEXT_FLAG_UNDERLINE;
+								}
+								g_free(textdec);
+							}
+							if (weight)
+							{
+								if (!g_ascii_strcasecmp(weight, "normal"))
+								{
+									flags &= ~GNT_TEXT_FLAG_BOLD;
+									flags |= orig_flags & GNT_TEXT_FLAG_BOLD;
+								}
+								else if (!g_ascii_strcasecmp(weight, "bold") || !g_ascii_strcasecmp(weight, "bolder"))
+									flags |= GNT_TEXT_FLAG_BOLD;
+								else if (!g_ascii_strcasecmp(weight, "lighter"))
+									flags &= ~GNT_TEXT_FLAG_BOLD;
+								g_free(weight);
+							}
+
+							g_free(style);
+						}
+						break;
+					case 57:	/* /SPAN */
+						if (fonts)
+						{
+							ADD_TEXT;
+							flags = GPOINTER_TO_INT(fonts->data);
+							fonts = g_slist_remove(fonts, fonts->data);
+						}
+						break;
+					case 62:	/* comment */
+						ADD_TEXT;
+						break;
+					default:
+						break;
+				}
+				c += tlen;
+				g_free(tag); /* This was allocated back in VALID_TAG() */
+			} else if (*c == '&' && (amp = purple_markup_unescape_entity(c, &tlen))) {
+				br = FALSE;
+				while(*amp) {
+					ws [wpos++] = *amp++;
+				}
+				c += tlen;
+			} else if (*c == '\n') {
+				if (!br) {  /* Don't insert a space immediately after an HTML break */
+					/* A newline is defined by HTML as whitespace, which means we have to replace it with a word boundary.
+					 * word breaks vary depending on the language used, so the correct thing to do is to use Pango to determine
+					 * what language this is, determine the proper word boundary to use, and insert that. I'm just going to insert
+					 * a space instead.  What are the non-English speakers going to do?  Complain in a language I'll understand?
+					 * Bu-wahaha! */
+					ws[wpos++] = ' ';
+				}
+				c++;
+			} else {
+				br = FALSE;
+				ws [wpos++] = *c++;
+			}
+		}
+		ADD_TEXT;
+
+		while (fonts)
+			fonts = g_slist_remove(fonts, fonts->data);
+
+		g_free(ws);
+}
+
diff --git a/finch/gntimhtml.h b/finch/gntimhtml.h
new file mode 100644
index 0000000000..7760353951
--- /dev/null
+++ b/finch/gntimhtml.h
@@ -0,0 +1,48 @@
+/**
+ * @file gntimhtml.h GNT IM/HTML rendering component
+ * @ingroup finch
+ */
+
+/* finch
+ *
+ * Finch is the legal property of its developers, whose names are too numerous
+ * to list here.  Please refer to the COPYRIGHT file distributed with this
+ * source distribution.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02111-1301  USA
+ */
+#ifndef _GNT_IMHTML_H
+#define _GNT_IMHTML_H
+
+#include <gnt.h>
+#include "gnttextview.h"
+
+/**************************************************************************
+ * @name GNT IM/HTML rendering component API
+ **************************************************************************/
+/*@{*/
+
+/**
+ * Inserts HTML formatted text to a GNT Textview.
+ *
+ * @param imhtml  The GNT Textview.
+ * @param text    The formatted text to append.
+ * @param flags  The text-flags to apply to the new text.
+ */
+void gnt_imhtml_append_markup(GntTextView *view, const char *text, GntTextFormatFlags flags);
+
+/*@}*/
+
+#endif /* _GNT_IMHTML_H */
diff --git a/finch/gntnotify.c b/finch/gntnotify.c
index d4d6fd63de..af17847529 100644
--- a/finch/gntnotify.c
+++ b/finch/gntnotify.c
@@ -93,7 +93,7 @@ finch_notify_common(PurpleNotifyType ntype, PurpleNotifyMsgType msgtype,
 			gnt_text_view_set_flag(GNT_TEXT_VIEW(msg), GNT_TEXT_VIEW_TOP_ALIGN | GNT_TEXT_VIEW_NO_SCROLL);
 
 			plain = purple_markup_strip_html(secondary);
-			if (!gnt_util_parse_xhtml_to_textview(secondary, GNT_TEXT_VIEW(msg)))
+			if (!gnt_util_parse_xhtml_to_textview(secondary, GNT_TEXT_VIEW(msg), 0))
 				gnt_text_view_append_text_with_flags(GNT_TEXT_VIEW(msg), plain, sf);
 
 			gnt_text_view_attach_scroll_widget(GNT_TEXT_VIEW(msg), button);
@@ -347,7 +347,7 @@ finch_notify_userinfo(PurpleConnection *gc, const char *who, PurpleNotifyUserInf
 		gnt_widget_get_size(GNT_WIDGET(msg), &tvw, &tvh);
 
 		gnt_text_view_clear(msg);
-		if (!gnt_util_parse_xhtml_to_textview(info, msg))
+		if (!gnt_util_parse_xhtml_to_textview(info, msg, 0))
 			gnt_text_view_append_text_with_flags(msg, strip, GNT_TEXT_FLAG_NORMAL);
 		gnt_text_view_scroll(msg, 0);
 		gnt_util_get_text_bound(strip, &ntvw, &ntvh);
diff --git a/finch/gntprefs.c b/finch/gntprefs.c
index 82ff9d58a6..0b8ee2d02d 100644
--- a/finch/gntprefs.c
+++ b/finch/gntprefs.c
@@ -53,11 +53,11 @@ void finch_prefs_init()
 
 	purple_prefs_add_none("/finch/conversations");
 	purple_prefs_add_bool("/finch/conversations/timestamps", TRUE);
+	purple_prefs_add_string("/finch/conversations/timestamp_fmt", "(%H:%M:%S)");
 	purple_prefs_add_bool("/finch/conversations/notify_typing", FALSE);
 
 	purple_prefs_add_none("/finch/filelocations");
 	purple_prefs_add_path("/finch/filelocations/last_save_folder", "");
-	purple_prefs_add_path("/finch/filelocations/last_save_folder", "");
 }
 
 void finch_prefs_update_old()
@@ -192,6 +192,7 @@ static Prefs blist[] =
 static Prefs convs[] =
 {
 	{PURPLE_PREF_BOOLEAN, "/finch/conversations/timestamps", N_("Show Timestamps"), NULL},
+	{PURPLE_PREF_STRING, "/finch/conversations/timestamp_fmt", N_("Timestamp Format"), NULL},
 	{PURPLE_PREF_BOOLEAN, "/finch/conversations/notify_typing", N_("Notify buddies when you are typing"), NULL},
 	{PURPLE_PREF_NONE, NULL, NULL, NULL}
 };
diff --git a/libpurple/conversation.c b/libpurple/conversation.c
index acfc875be0..83f0596990 100644
--- a/libpurple/conversation.c
+++ b/libpurple/conversation.c
@@ -382,6 +382,8 @@ purple_conversation_new(PurpleConversationType type, PurpleAccount *account,
 	PurpleConnection *gc;
 	PurpleConversationUiOps *ops;
 	struct _purple_hconv *hc;
+	gboolean log = FALSE;
+	PurpleBlistNode *node = NULL;
 
 	g_return_val_if_fail(type    != PURPLE_CONV_TYPE_UNKNOWN, NULL);
 	g_return_val_if_fail(account != NULL, NULL);
@@ -433,6 +435,8 @@ purple_conversation_new(PurpleConversationType type, PurpleAccount *account,
 	if (type == PURPLE_CONV_TYPE_IM)
 	{
 		PurpleBuddyIcon *icon;
+		PurpleBuddy *b;
+
 		conv->u.im = g_new0(PurpleConvIm, 1);
 		conv->u.im->conv = conv;
 		PURPLE_DBUS_REGISTER_POINTER(conv->u.im, PurpleConvIm);
@@ -445,17 +449,16 @@ purple_conversation_new(PurpleConversationType type, PurpleAccount *account,
 			purple_buddy_icon_unref(icon);
 		}
 
-		if (purple_prefs_get_bool("/purple/logging/log_ims"))
-		{
-			purple_conversation_set_logging(conv, TRUE);
-			open_log(conv);
-		}
+		log = purple_prefs_get_bool("/purple/logging/log_ims");
+		if ((b = purple_find_buddy(account, name)))
+			node = &b->node;
 
 		purple_conversation_ensure_buddy(account, gc, name);
 	}
 	else if (type == PURPLE_CONV_TYPE_CHAT)
 	{
 		const char *disp;
+		PurpleChat *c;
 
 		conv->u.chat = g_new0(PurpleConvChat, 1);
 		conv->u.chat->conv = conv;
@@ -471,11 +474,18 @@ purple_conversation_new(PurpleConversationType type, PurpleAccount *account,
 			purple_conv_chat_set_nick(conv->u.chat,
 									purple_account_get_username(account));
 
-		if (purple_prefs_get_bool("/purple/logging/log_chats"))
-		{
-			purple_conversation_set_logging(conv, TRUE);
-			open_log(conv);
-		}
+		log = purple_prefs_get_bool("/purple/logging/log_chats");
+		if ((c = purple_blist_find_chat(account, name)))
+			node = &c->node;
+	}
+
+	if (!log && node)
+		log = purple_blist_node_get_bool(node, "log");
+
+	if (log)
+	{
+		purple_conversation_set_logging(conv, TRUE);
+		open_log(conv);
 	}
 
 	conversations = g_list_prepend(conversations, conv);
@@ -956,6 +966,7 @@ purple_find_conversation_with_account(PurpleConversationType type,
 	switch (type) {
 		case PURPLE_CONV_TYPE_IM:
 		case PURPLE_CONV_TYPE_CHAT:
+		case PURPLE_CONV_TYPE_MISC:
 			c = g_hash_table_lookup(conversation_cache, &hc);
 			break;
 		case PURPLE_CONV_TYPE_ANY:
diff --git a/libpurple/log.c b/libpurple/log.c
index 9fb9f4d4ec..77b8e53d43 100644
--- a/libpurple/log.c
+++ b/libpurple/log.c
@@ -51,6 +51,7 @@ static GHashTable *logsize_users_decayed = NULL;
 
 static void log_get_log_sets_common(GHashTable *sets);
 
+static void html_logger_create(PurpleLog *log);
 static gsize html_logger_write(PurpleLog *log, PurpleMessageFlags type,
 							  const char *from, time_t time, const char *message);
 static void html_logger_finalize(PurpleLog *log);
@@ -66,6 +67,7 @@ static int old_logger_size (PurpleLog *log);
 static void old_logger_get_log_sets(PurpleLogSetCallback cb, GHashTable *sets);
 static void old_logger_finalize(PurpleLog *log);
 
+static void txt_logger_create(PurpleLog *log);
 static gsize txt_logger_write(PurpleLog *log,
 							 PurpleMessageFlags type,
 							 const char *from, time_t time, const char *message);
@@ -653,7 +655,7 @@ void purple_log_init(void)
 	purple_prefs_add_string("/purple/logging/format", "html");
 
 	html_logger = purple_log_logger_new("html", _("HTML"), 11,
-									  NULL,
+									  html_logger_create,
 									  html_logger_write,
 									  html_logger_finalize,
 									  html_logger_list,
@@ -667,7 +669,7 @@ void purple_log_init(void)
 	purple_log_logger_add(html_logger);
 
 	txt_logger = purple_log_logger_new("txt", _("Plain text"), 11,
-									 NULL,
+									 txt_logger_create,
 									 txt_logger_write,
 									 txt_logger_finalize,
 									 txt_logger_list,
@@ -755,7 +757,7 @@ static char *log_get_timestamp(PurpleLog *log, time_t when)
 	char *date;
 	struct tm *tm;
 
-	show_date = (log->type == PURPLE_LOG_SYSTEM) || (time(NULL) > when + 20*60);
+	show_date = TRUE;
 
 	date = purple_signal_emit_return_1(purple_log_get_handle(),
 	                          "log-timestamp",
@@ -1369,14 +1371,9 @@ static PurpleLogLogger xml_logger =  {
  ** HTML LOGGER *************
  ****************************/
 
-static gsize html_logger_write(PurpleLog *log, PurpleMessageFlags type,
-							  const char *from, time_t time, const char *message)
+static void html_logger_create(PurpleLog *log)
 {
-	char *msg_fixed;
-	char *image_corrected_msg;
-	char *date;
 	char *header;
-	char *escaped_from;
 	PurplePlugin *plugin = purple_find_prpl(purple_account_get_protocol_id(log->account));
 	PurpleLogCommonLoggerData *data = log->logger_data;
 	gsize written = 0;
@@ -1391,7 +1388,7 @@ static gsize html_logger_write(PurpleLog *log, PurpleMessageFlags type,
 
 		/* if we can't write to the file, give up before we hurt ourselves */
 		if(data == NULL || data->file == NULL)
-			return 0;
+			return;
 
 		date = purple_date_format_full(localtime(&log->time));
 
@@ -1410,6 +1407,22 @@ static gsize html_logger_write(PurpleLog *log, PurpleMessageFlags type,
 		written += fprintf(data->file, "<h1>%s</h1><p>\n", header);
 		g_free(header);
 	}
+}
+
+static gsize html_logger_write(PurpleLog *log, PurpleMessageFlags type,
+							  const char *from, time_t time, const char *message)
+{
+	char *msg_fixed;
+	char *image_corrected_msg;
+	char *date;
+	char *escaped_from;
+	PurpleLogCommonLoggerData *data = log->logger_data;
+	gsize written = 0;
+
+	if(!data) {
+		html_logger_create(log);
+		data = log->logger_data;
+	}
 
 	/* if we can't write to the file, give up before we hurt ourselves */
 	if(!data->file)
@@ -1527,15 +1540,10 @@ static int html_logger_total_size(PurpleLogType type, const char *name, PurpleAc
  ** PLAIN TEXT LOGGER *******
  ****************************/
 
-static gsize txt_logger_write(PurpleLog *log,
-							 PurpleMessageFlags type,
-							 const char *from, time_t time, const char *message)
+static void txt_logger_create(PurpleLog *log)
 {
-	char *date;
 	PurplePlugin *plugin = purple_find_prpl(purple_account_get_protocol_id(log->account));
 	PurpleLogCommonLoggerData *data = log->logger_data;
-	char *stripped = NULL;
-
 	gsize written = 0;
 
 	if (data == NULL) {
@@ -1551,7 +1559,7 @@ static gsize txt_logger_write(PurpleLog *log,
 
 		/* if we can't write to the file, give up before we hurt ourselves */
 		if(data == NULL || data->file == NULL)
-			return 0;
+			return;
 
 		if (log->type == PURPLE_LOG_SYSTEM)
 			written += fprintf(data->file, "System log for account %s (%s) connected at %s\n",
@@ -1562,6 +1570,22 @@ static gsize txt_logger_write(PurpleLog *log,
 				log->name, purple_date_format_full(localtime(&log->time)),
 				purple_account_get_username(log->account), prpl);
 	}
+}
+
+static gsize txt_logger_write(PurpleLog *log,
+							 PurpleMessageFlags type,
+							 const char *from, time_t time, const char *message)
+{
+	char *date;
+	PurpleLogCommonLoggerData *data = log->logger_data;
+	char *stripped = NULL;
+
+	gsize written = 0;
+
+	if (data == NULL) {
+		txt_logger_create(log);
+		data = log->logger_data;
+	}
 
 	/* if we can't write to the file, give up before we hurt ourselves */
 	if(!data->file)
diff --git a/libpurple/media/backend-fs2.h b/libpurple/media/backend-fs2.h
index 47fb02dac5..e6d54e4237 100644
--- a/libpurple/media/backend-fs2.h
+++ b/libpurple/media/backend-fs2.h
@@ -60,6 +60,7 @@ GType purple_media_backend_fs2_get_type(void);
  * Temporary function in order to be able to test while
  * integrating with PurpleMedia
  */
+#ifdef USE_GSTREAMER
 #include <gst/gst.h>
 GstElement *purple_media_backend_fs2_get_src(
 		PurpleMediaBackendFs2 *self,
@@ -71,6 +72,7 @@ void purple_media_backend_fs2_set_input_volume(PurpleMediaBackendFs2 *self,
 		const gchar *sess_id, double level);
 void purple_media_backend_fs2_set_output_volume(PurpleMediaBackendFs2 *self,
 		const gchar *sess_id, const gchar *who, double level);
+#endif
 /* end tmp */
 #endif /* USE_GSTREAMER */
 
diff --git a/libpurple/plugins/Makefile.am b/libpurple/plugins/Makefile.am
index dd9f07e465..570034f025 100644
--- a/libpurple/plugins/Makefile.am
+++ b/libpurple/plugins/Makefile.am
@@ -42,6 +42,9 @@ psychic_la_LDFLAGS          = -module -avoid-version
 signals_test_la_LDFLAGS		= -module -avoid-version
 simple_la_LDFLAGS			= -module -avoid-version
 statenotify_la_LDFLAGS      = -module -avoid-version
+statelog_la_LDFLAGS      = -module -avoid-version
+syncnotify_la_LDFLAGS      = -module -avoid-version
+alertcount_la_LDFLAGS      = -module -avoid-version
 
 # this can't be in a conditional otherwise automake 1.4 yells
 dbus_example_la_LDFLAGS     = -module -avoid-version
@@ -58,6 +61,9 @@ plugin_LTLIBRARIES = \
 	offlinemsg.la       \
 	psychic.la          \
 	statenotify.la      \
+	statelog.la      \
+	syncnotify.la      \
+	alertcount.la      \
 	$(DBUS_LTLIB)
 
 noinst_LTLIBRARIES = \
@@ -89,6 +95,9 @@ psychic_la_SOURCES          = psychic.c
 signals_test_la_SOURCES		= signals-test.c
 simple_la_SOURCES			= simple.c
 statenotify_la_SOURCES      = statenotify.c
+statelog_la_SOURCES      = statelog.c
+syncnotify_la_SOURCES      = syncnotify.c
+alertcount_la_SOURCES      = alertcount.c
 
 autoaccept_la_LIBADD        = $(GLIB_LIBS)
 buddynote_la_LIBADD         = $(GLIB_LIBS)
@@ -106,6 +115,9 @@ psychic_la_LIBADD           = $(GLIB_LIBS)
 signals_test_la_LIBADD		= $(GLIB_LIBS)
 simple_la_LIBADD			= $(GLIB_LIBS)
 statenotify_la_LIBADD       = $(GLIB_LIBS)
+statelog_la_LIBADD       = $(GLIB_LIBS)
+syncnotify_la_LIBADD       = $(GLIB_LIBS)
+alertcount_la_LIBADD       = $(GLIB_LIBS)
 
 if ENABLE_DBUS
 
diff --git a/libpurple/plugins/alertcount.c b/libpurple/plugins/alertcount.c
new file mode 100644
index 0000000000..a19148e35a
--- /dev/null
+++ b/libpurple/plugins/alertcount.c
@@ -0,0 +1,359 @@
+#define _GNU_SOURCE
+#include "internal.h"
+#include "debug.h"
+#include "plugin.h"
+#include "version.h"
+
+/** Plugin id : type-author-name (to guarantee uniqueness) */
+#define ALERTS_PLUGIN_ID "core-dylex-alertcount"
+
+static int Listener = -1;
+static guint Incoming = 0;
+static int Connection = -1;
+static guint Outgoing = 0;
+static int Count = -1;
+
+#ifdef ACTIVITY
+static struct activity {
+	struct activity *next;
+	PurpleConversation *conv;
+	uint16_t count;
+	uint8_t ident;
+} *Activity = NULL;
+#endif
+
+static PurpleBlistNode *
+conversation_buddy(PurpleConversation *conv)
+{
+	switch (conv->type) {
+		case PURPLE_CONV_TYPE_IM:
+			return PURPLE_BLIST_NODE(purple_find_buddy(conv->account, conv->name));
+		case PURPLE_CONV_TYPE_CHAT:
+			return PURPLE_BLIST_NODE(purple_blist_find_chat(conv->account, conv->name));
+		default:
+			return NULL;
+	}
+}
+
+static gboolean
+conversation_ignore(PurpleConversation *conv)
+{
+	return !strcmp(conv->name, "slackbot")
+		|| !strcmp(conv->name, "NickServ");
+}
+
+static uint8_t
+conversation_ident(PurpleConversation *conv)
+{
+	PurpleBlistNode *blist;
+	unsigned h = 0x7f;
+
+	if (conversation_ignore(conv))
+		return 0;
+
+	blist = conversation_buddy(conv);
+	if (blist) {
+		int r = purple_blist_node_get_int(blist, "alertcount");
+		if (r < 0)
+			return 0;
+		if (r)
+			return r;
+	}
+
+#ifdef HASH_NAME
+	char *name;
+	if (blist)
+		name = PURPLE_BLIST_NODE_NAME(blist);
+	if (!name)
+		name = conv->name;
+	/* hack to get rid of variables resource markers (jabber only?) */
+	char *p = strchrnul(strchrnul(name, '@'), '/');
+	char o = *p;
+	*p = '\0';
+	h = g_str_hash(name);
+	*p = o;
+	while (!(h & 0x7F) && h)
+		h >>= 7;
+#endif
+	if (!h)
+		h = 0x7F;
+	return (conv->type << 7) | (h & 0x7F);
+}
+
+#ifdef ACTIVITY
+static void
+activity_update(PurpleConversation *conv, int count)
+{
+	struct activity **p, *a;
+	for (p = &Activity; *p && (*p)->conv != conv; p = &(*p)->next);
+	if ((a = *p)) {
+		if (count)
+			a->count = count;
+		else {
+			*p = a->next;
+			g_slice_free(struct activity, a);
+		}
+	} else if (count) {
+		a = *p = g_slice_new(struct activity);
+		a->next = NULL;
+		a->conv = conv;
+		a->count = count;
+		a->ident = conversation_ident(conv);
+	}
+}
+#endif
+
+static unsigned
+alerts_get_count(uint8_t *buf, size_t buflen)
+{
+	const gboolean aggregate = purple_prefs_get_bool("/plugins/core/alertcount/aggregate");
+	unsigned count = 0;
+	GList *l;
+	if (!aggregate)
+		buflen &= ~1;
+
+	for (l = purple_get_conversations(); l != NULL; l = l->next) {
+		PurpleConversation *conv = (PurpleConversation *)l->data;
+		int c = GPOINTER_TO_INT(purple_conversation_get_data(conv, "unseen-count"));
+		uint8_t id;
+		if (!c)
+			continue;
+		id = conversation_ident(conv);
+		purple_debug_misc("alertcount", "conversation %s = %u\n", conv->name, id);
+		if (!id)
+			continue;
+		if (count < buflen) {
+			buf[count++] = id;
+			if (!aggregate)
+				buf[count++] = c;
+		} else if (aggregate)
+			count ++;
+		else
+			count += c;
+	}
+	Count = count;
+	return count;
+}
+
+static void
+alerts_outgoing_cb(gpointer data, gint source, PurpleInputCondition cond)
+{
+	const gboolean ident = purple_prefs_get_bool("/plugins/core/alertcount/ident");
+	unsigned c;
+	uint8_t buf[128];
+
+	if (Outgoing) {
+		purple_input_remove(Outgoing);
+		Outgoing = 0;
+	}
+
+	c = alerts_get_count(buf, ident ? 127 : 0);
+	if (c > 127)
+		c = 127;
+	if (ident)
+		buf[c++] = 0;
+	else {
+		*buf = c;
+		c = 1;
+	}
+	if (send(Connection, buf, c, 0) <= 0) { /* ignore short reads */
+		purple_debug_info("alertcount", "send: %m\n");
+		close(Connection);
+		Connection = -1;
+	}
+}
+
+static void
+alerts_incoming_cb(gpointer data, gint source, PurpleInputCondition cond)
+{
+	struct sockaddr_in addr;
+	socklen_t addrlen = sizeof(addr);
+
+	if (Outgoing) {
+		purple_input_remove(Outgoing);
+		Outgoing = 0;
+	}
+	if (Connection >= 0)
+		close(Connection);
+	if ((Connection = accept(Listener, (struct sockaddr *)&addr, &addrlen)) < 0)
+	{
+		purple_debug_warning("alertcount", "accept: %m\n");
+		return;
+	}
+
+	purple_debug_info("alertcount", "accepted connection from %s:%hu\n", inet_ntoa(addr.sin_addr), ntohs(addr.sin_port));
+	shutdown(Connection, SHUT_RD);
+	fcntl(Connection, F_SETFL, O_NONBLOCK);
+	fcntl(Connection, F_SETFD, FD_CLOEXEC);
+
+	Outgoing = purple_input_add(Connection, PURPLE_INPUT_WRITE, alerts_outgoing_cb, NULL);
+}
+
+static void
+alerts_conversation_cb(PurpleConversation *conv, PurpleConvUpdateType type, void *data)
+{
+	int c;
+
+	if (type != PURPLE_CONV_UPDATE_UNSEEN)
+		return;
+	if (Connection < 0 || Outgoing)
+		return;
+	if (conversation_ignore(conv))
+		return;
+	c = GPOINTER_TO_INT(purple_conversation_get_data(conv, "unseen-count"));
+	if (!Count && !c)
+		return;
+#ifdef ACTIVITY
+	activity_update(conv, c);
+#endif
+	Outgoing = purple_input_add(Connection, PURPLE_INPUT_WRITE, alerts_outgoing_cb, NULL);
+}
+
+static gboolean
+plugin_load(PurplePlugin *plugin)
+{
+	const int on = 1;
+	const struct sockaddr_in addr = {
+		.sin_family = AF_INET,
+		.sin_port = htons(purple_prefs_get_int("/plugins/core/alertcount/port")),
+		.sin_addr = { htonl(INADDR_LOOPBACK) }
+	};
+
+	if ((Listener = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
+		purple_debug_error("alertcount", "socket: %m\n");
+		goto error;
+	}
+	if (setsockopt(Listener, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on)) < 0)
+		purple_debug_warning("alertcount", "setsockopt(SO_REUSEADDR): %m\n");
+	if (bind(Listener, (struct sockaddr *)&addr, sizeof(addr)) < 0)
+	{
+		purple_debug_error("alertcount", "bind: %m\n");
+		goto error;
+	}
+	if (listen(Listener, 1) < 0) {
+		purple_debug_error("alertcount", "listen: %m\n");
+		goto error;
+	}
+
+	fcntl(Listener, F_SETFL, O_NONBLOCK);
+	fcntl(Listener, F_SETFD, FD_CLOEXEC);
+
+	Incoming = purple_input_add(Listener, PURPLE_INPUT_READ, alerts_incoming_cb, NULL);
+
+	purple_signal_connect(purple_conversations_get_handle(), "conversation-updated",
+			plugin, PURPLE_CALLBACK(alerts_conversation_cb), NULL);
+
+	return TRUE;
+
+error:
+	if (Listener >= 0) {
+		close(Listener);
+		Listener = -1;
+	}
+	return FALSE;
+}
+
+static gboolean
+plugin_unload(PurplePlugin *plugin)
+{
+#ifdef ACTIVITY
+	if (Activity) {
+		g_slice_free_chain(struct activity, Activity, next);
+		Activity = NULL;
+	}
+#endif
+	if (Outgoing) {
+		purple_input_remove(Outgoing);
+		Outgoing = 0;
+	}
+	if (Incoming) {
+		purple_input_remove(Incoming);
+		Incoming = 0;
+	}
+	if (Connection >= 0) {
+		close(Connection);
+		Connection = -1;
+	}
+	if (Listener >= 0) {
+		close(Listener);
+		Listener = -1;
+	}
+	return TRUE;
+}
+
+static PurplePluginPrefFrame *
+get_plugin_pref_frame(PurplePlugin *plugin)
+{
+	PurplePluginPrefFrame *frame;
+	PurplePluginPref *ppref;
+
+	frame = purple_plugin_pref_frame_new();
+
+	ppref = purple_plugin_pref_new_with_name_and_label("/plugins/core/alertcount/port", _("Listen on _port"));
+	purple_plugin_pref_frame_add(frame, ppref);
+
+	ppref = purple_plugin_pref_new_with_name_and_label("/plugins/core/alertcount/aggregate", _("_Aggregate conversation"));
+	purple_plugin_pref_frame_add(frame, ppref);
+
+	ppref = purple_plugin_pref_new_with_name_and_label("/plugins/core/alertcount/ident", _("_Identify conversations"));
+	purple_plugin_pref_frame_add(frame, ppref);
+
+	return frame;
+}
+
+static PurplePluginUiInfo prefs_info =
+{
+	get_plugin_pref_frame,
+	0,   /* page_num (Reserved) */
+	NULL, /* frame (Reserved) */
+	NULL,
+	NULL,
+	NULL,
+	NULL
+};
+
+static PurplePluginInfo info =
+{
+	PURPLE_PLUGIN_MAGIC,
+	PURPLE_MAJOR_VERSION,
+	PURPLE_MINOR_VERSION,
+	PURPLE_PLUGIN_STANDARD,                             /**< type           */
+	NULL,                                             /**< ui_requirement */
+	0,                                                /**< flags          */
+	NULL,                                             /**< dependencies   */
+	PURPLE_PRIORITY_DEFAULT,                            /**< priority       */
+
+	ALERTS_PLUGIN_ID,                                 /**< id             */
+	N_("Alert Count Server"),                              /**< name           */
+	DISPLAY_VERSION,                                  /**< version        */
+	                                                  /**  summary        */
+	N_("Exports unseen conversation count to a single network listener."),
+	                                                  /**  description    */
+	N_("Exports unseen conversation count to a single network listener."),
+	"Dylan Simon <dylan@dylex.net>",        /**< author         */
+	NULL,                                     /**< homepage       */
+
+	plugin_load,                                      /**< load           */
+	plugin_unload,                                    /**< unload         */
+	NULL,                                             /**< destroy        */
+
+	NULL,                                             /**< ui_info        */
+	NULL,                                             /**< extra_info     */
+	&prefs_info,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL
+};
+
+static void
+init_plugin(PurplePlugin *plugin)
+{
+	purple_prefs_add_none("/plugins/core/alertcount");
+	purple_prefs_add_int("/plugins/core/alertcount/port", 6652);
+	purple_prefs_add_bool("/plugins/core/alertcount/aggregate", TRUE);
+	purple_prefs_add_bool("/plugins/core/alertcount/ident", FALSE);
+}
+
+PURPLE_INIT_PLUGIN(alertcount, init_plugin, info)
diff --git a/libpurple/plugins/statelog.c b/libpurple/plugins/statelog.c
new file mode 100644
index 0000000000..174e03a5ff
--- /dev/null
+++ b/libpurple/plugins/statelog.c
@@ -0,0 +1,344 @@
+#include "internal.h"
+#include "debug.h"
+#include "plugin.h"
+#include "version.h"
+#include "blist.h"
+
+/** Plugin id : type-author-name (to guarantee uniqueness) */
+#define STATELOG_PLUGIN_ID "core-dylex-statelog"
+
+struct BuddyState {
+	time_t conn, idle;
+	gboolean away;
+	char *msg;
+};
+
+static GHashTable *buddy_states;
+
+static void buddy_state_free(struct BuddyState *bs)
+{
+	if (bs->msg)
+		g_free(bs->msg);
+	g_free(bs);
+}
+
+static char *msg_dup(const char *msg)
+{
+	gsize n = strlen(msg);
+	if (!strncasecmp(msg, "<html>", 6))
+	{
+		msg += 6;
+		n -= 6;
+	}
+	if (!strncasecmp(msg, "<body>", 6))
+	{
+		msg += 6;
+		n -= 6;
+	}
+	if (n >= 7 && !strncasecmp(msg+n-7, "</html>", 7))
+	{
+		n -= 7;
+	}
+	if (n >= 7 && !strncasecmp(msg+n-7, "</body>", 7))
+	{
+		n -= 7;
+	}
+	return g_strndup(msg, n);
+}
+
+static void
+update_state(PurpleBuddy *buddy) // , time_t when, const char *status, const char *msg)
+{
+	struct BuddyState *curr;
+	const char *who;
+	char *escaped;
+	const PurplePresence *presence;
+	const PurpleStatus *status;
+	time_t when = 0, conn, idle;
+	const char *msg;
+	gboolean away;
+	gboolean changed = FALSE;
+	GString *buf;
+
+	who = purple_buddy_get_alias(buddy);
+	escaped = g_markup_escape_text(who, -1);
+	buf = g_string_new(escaped);
+	g_free(escaped);
+
+	curr = g_hash_table_lookup(buddy_states, buddy);
+	if (!curr)
+	{
+		curr = g_new0(struct BuddyState, 1);
+		g_hash_table_insert(buddy_states, buddy, curr);
+	}
+
+	presence = purple_buddy_get_presence(buddy);
+	status = purple_presence_get_active_status(presence);
+
+	if (purple_presence_is_online(presence))
+	{
+		if (!(conn = purple_presence_get_login_time(presence)))
+			if (!(conn = curr->conn))
+				time(&conn);
+	}
+	else
+		conn = 0;
+	if (purple_prefs_get_bool("/plugins/core/statelog/log_conn")
+			&& conn != curr->conn)
+	{
+		if (conn)
+		{
+			when = conn;
+			g_string_append(buf, " <font color=\"yellow\">signon</font>");
+		}
+		else
+			g_string_append(buf, " <font color=\"red\">signoff</font>");
+		curr->conn = conn;
+		changed = TRUE;
+	}
+
+	if (purple_presence_is_idle(presence))
+	{
+		idle = purple_presence_get_idle_time(presence);
+		if (!idle) time(&idle);
+	}
+	else
+		idle = 0;
+	if (conn && purple_prefs_get_bool("/plugins/core/statelog/log_idle")
+			&& idle != curr->idle)
+	{
+		if (idle)
+		{
+			if (!when) when = idle;
+			g_string_append(buf, " <font color=\"cyan\">idle</font>");
+		}
+		else
+			g_string_append(buf, " unidle");
+		curr->idle = idle;
+		changed = TRUE;
+	}
+
+	if (conn && purple_prefs_get_bool("/plugins/core/statelog/log_away")
+			&& (away = !purple_status_is_available(status)) != curr->away)
+	{
+		if (away)
+			g_string_append_printf(buf, " <font color=\"green\">%s</font>", purple_status_get_name(status) ?: "away");
+		else
+			g_string_append_printf(buf, " %s", purple_status_get_name(status) ?: "back");
+		curr->away = away;
+		changed = TRUE;
+	}
+
+	if (purple_prefs_get_bool("/plugins/core/statelog/log_msg") 
+			&& (msg = purple_status_get_attr_string(status, "message"))
+			&& (!curr->msg || strcmp(msg, curr->msg)))
+	{
+		/* XXX clear if msg == NULL? */
+		gchar *cmsg = msg_dup(msg);
+		if (!curr->msg || strcmp(cmsg, curr->msg))
+		{
+			purple_debug_info("statelog", "changing msg from '%s' to '%s'\n", curr->msg, cmsg);
+			g_string_append_printf(buf, ": %s", cmsg);
+			if (curr->msg) g_free(curr->msg);
+			curr->msg = cmsg;
+			changed = TRUE;
+		}
+		else
+		{
+			g_free(cmsg);
+		}
+	}
+
+	if (!changed)
+	{
+		g_string_free(buf, TRUE);
+		return;
+	}
+
+	if (!when) time(&when);
+
+	if (purple_prefs_get_bool("/plugins/core/statelog/to_conv")) {
+		PurpleConversation *conv = purple_find_conversation_with_account(PURPLE_CONV_TYPE_IM, buddy->name, buddy->account);
+		if (conv && conv->type == PURPLE_CONV_TYPE_IM)
+			purple_conv_im_write(conv->u.im, NULL, buf->str, PURPLE_MESSAGE_SYSTEM | PURPLE_MESSAGE_ACTIVE_ONLY | PURPLE_MESSAGE_NO_LOG, when);
+	}
+
+	if (purple_prefs_get_bool("/plugins/core/statelog/collapsed") || !purple_blist_node_get_bool(&purple_buddy_get_group(buddy)->node, "collapsed"))
+	{
+		if (purple_prefs_get_bool("/plugins/core/statelog/to_acct")) {
+			PurpleLog *log = purple_account_get_log(buddy->account, FALSE);
+			if (log)
+				purple_log_write(log, PURPLE_MESSAGE_SYSTEM, who, when, buf->str);
+		}
+
+		if (purple_prefs_get_bool("/plugins/core/statelog/to_self")) {
+			PurpleConversation *conv = purple_find_conversation_with_account(PURPLE_CONV_TYPE_MISC, "state", buddy->account);
+			if (!conv)
+				conv = purple_conversation_new(PURPLE_CONV_TYPE_MISC, buddy->account, "state");
+			if (conv)
+				purple_conversation_write(conv, who, buf->str, PURPLE_MESSAGE_SYSTEM | PURPLE_MESSAGE_ACTIVE_ONLY, when);
+		}
+	}
+
+	g_string_free(buf, TRUE);
+}
+
+static void
+buddy_status_changed_cb(PurpleBuddy *buddy, PurpleStatus *old_status,
+                        PurpleStatus *status, void *data)
+{
+	update_state(buddy);
+}
+
+static void
+buddy_idle_changed_cb(PurpleBuddy *buddy, gboolean old_idle, gboolean idle,
+                      void *data)
+{
+	update_state(buddy);
+}
+
+static void
+buddy_signon_cb(PurpleBuddy *buddy, void *data)
+{
+	update_state(buddy);
+}
+
+static void
+buddy_signoff_cb(PurpleBuddy *buddy, void *data)
+{
+	update_state(buddy);
+}
+
+static PurplePluginPrefFrame *
+get_plugin_pref_frame(PurplePlugin *plugin)
+{
+	PurplePluginPrefFrame *frame;
+	PurplePluginPref *ppref;
+
+	frame = purple_plugin_pref_frame_new();
+
+	ppref = purple_plugin_pref_new_with_label(_("Log To"));
+	purple_plugin_pref_frame_add(frame, ppref);
+
+	ppref = purple_plugin_pref_new_with_name_and_label("/plugins/core/statelog/to_conv", _("_Buddy Conversation"));
+	purple_plugin_pref_frame_add(frame, ppref);
+
+	ppref = purple_plugin_pref_new_with_name_and_label("/plugins/core/statelog/to_acct", _("Account _Log"));
+	purple_plugin_pref_frame_add(frame, ppref);
+
+	ppref = purple_plugin_pref_new_with_name_and_label("/plugins/core/statelog/to_self", _("_State Conversation"));
+	purple_plugin_pref_frame_add(frame, ppref);
+
+	ppref = purple_plugin_pref_new_with_label(_("Log When"));
+	purple_plugin_pref_frame_add(frame, ppref);
+
+	ppref = purple_plugin_pref_new_with_name_and_label("/plugins/core/statelog/log_away", _("Buddy Goes _Away"));
+	purple_plugin_pref_frame_add(frame, ppref);
+
+	ppref = purple_plugin_pref_new_with_name_and_label("/plugins/core/statelog/log_idle", _("Buddy Goes _Idle"));
+	purple_plugin_pref_frame_add(frame, ppref);
+
+	ppref = purple_plugin_pref_new_with_name_and_label("/plugins/core/statelog/log_conn", _("Buddy _Connects/Disconnects"));
+	purple_plugin_pref_frame_add(frame, ppref);
+
+	ppref = purple_plugin_pref_new_with_name_and_label("/plugins/core/statelog/collapsed", _("Buddy in Collapsed _Group"));
+	purple_plugin_pref_frame_add(frame, ppref);
+
+	ppref = purple_plugin_pref_new_with_name_and_label("/plugins/core/statelog/log_msg", _("Include Status _Message"));
+	purple_plugin_pref_frame_add(frame, ppref);
+
+	return frame;
+}
+
+static gboolean
+plugin_load(PurplePlugin *plugin)
+{
+	void *blist_handle = purple_blist_get_handle();
+
+	buddy_states = g_hash_table_new_full(NULL, NULL, NULL, (GDestroyNotify)buddy_state_free);
+
+	purple_signal_connect(blist_handle, "buddy-status-changed", plugin,
+	                    PURPLE_CALLBACK(buddy_status_changed_cb), NULL);
+	purple_signal_connect(blist_handle, "buddy-idle-changed", plugin,
+	                    PURPLE_CALLBACK(buddy_idle_changed_cb), NULL);
+	purple_signal_connect(blist_handle, "buddy-signed-on", plugin,
+	                    PURPLE_CALLBACK(buddy_signon_cb), NULL);
+	purple_signal_connect(blist_handle, "buddy-signed-off", plugin,
+	                    PURPLE_CALLBACK(buddy_signoff_cb), NULL);
+
+	purple_debug_info("statelog", "statelog plugin loaded.\n");
+
+	return TRUE;
+}
+
+static gboolean
+plugin_unload(PurplePlugin *plugin)
+{
+	purple_debug_info("statelog", "statelog plugin unloaded.\n");
+
+	g_hash_table_destroy(buddy_states);
+
+	return TRUE;
+}
+
+static PurplePluginUiInfo prefs_info =
+{
+	get_plugin_pref_frame,
+	0,   /* page_num (Reserved) */
+	NULL, /* frame (Reserved) */
+	NULL,
+	NULL,
+	NULL,
+	NULL
+};
+
+static PurplePluginInfo info =
+{
+	PURPLE_PLUGIN_MAGIC,
+	PURPLE_MAJOR_VERSION,
+	PURPLE_MINOR_VERSION,
+	PURPLE_PLUGIN_STANDARD,                             /**< type           */
+	NULL,                                             /**< ui_requirement */
+	0,                                                /**< flags          */
+	NULL,                                             /**< dependencies   */
+	PURPLE_PRIORITY_DEFAULT,                            /**< priority       */
+
+	STATELOG_PLUGIN_ID,                                 /**< id             */
+	N_("State Logger"),                              /**< name           */
+	DISPLAY_VERSION,                                  /**< version        */
+	                                                  /**  summary        */
+	N_("Logs presence changes and away messages of buddies."),
+	                                                  /**  description    */
+	N_("Logs presence changes and away messages of buddies.  Based on statenotify."),
+	"Dylan Simon <dylan@dylex.net>",        /**< author         */
+	NULL,                                     /**< homepage       */
+
+	plugin_load,                                      /**< load           */
+	plugin_unload,                                    /**< unload         */
+	NULL,                                             /**< destroy        */
+
+	NULL,                                             /**< ui_info        */
+	NULL,                                             /**< extra_info     */
+	&prefs_info,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL
+};
+
+static void
+init_plugin(PurplePlugin *plugin)
+{
+	purple_prefs_add_none("/plugins/core/statelog");
+	purple_prefs_add_bool("/plugins/core/statelog/to_conv", TRUE);
+	purple_prefs_add_bool("/plugins/core/statelog/to_acct", FALSE);
+	purple_prefs_add_bool("/plugins/core/statelog/to_self", FALSE);
+	purple_prefs_add_bool("/plugins/core/statelog/log_away", TRUE);
+	purple_prefs_add_bool("/plugins/core/statelog/log_idle", FALSE);
+	purple_prefs_add_bool("/plugins/core/statelog/log_conn", TRUE);
+	purple_prefs_add_bool("/plugins/core/statelog/log_msg", FALSE);
+	purple_prefs_add_bool("/plugins/core/statelog/collapsed", FALSE);
+}
+
+PURPLE_INIT_PLUGIN(statelog, init_plugin, info)
diff --git a/libpurple/plugins/statenotify.c b/libpurple/plugins/statenotify.c
index bfbe595e50..1ec35e2f1a 100644
--- a/libpurple/plugins/statenotify.c
+++ b/libpurple/plugins/statenotify.c
@@ -26,7 +26,7 @@ write_status(PurpleBuddy *buddy, const char *message)
 	buddy_name = purple_buddy_get_name(buddy);
 
 	conv = purple_find_conversation_with_account(PURPLE_CONV_TYPE_IM,
-												 buddy_name, account);
+			buddy_name, account);
 
 	if (conv == NULL)
 		return;
diff --git a/libpurple/plugins/syncnotify.c b/libpurple/plugins/syncnotify.c
new file mode 100644
index 0000000000..646ed5321f
--- /dev/null
+++ b/libpurple/plugins/syncnotify.c
@@ -0,0 +1,95 @@
+#include "internal.h"
+#include "debug.h"
+#include "plugin.h"
+#include "version.h"
+#include "blist.h"
+
+/** Plugin id : type-author-name (to guarantee uniqueness) */
+#define NOTIFY_PLUGIN_ID "core-dylex-syncnotify"
+
+#define PATH "/home/dylan/.sync-notify"
+static const struct sockaddr_un ADDR = {
+	AF_UNIX,
+	"/home/dylan/.sync-notify"
+};
+
+static void
+conversation_created_cb(PurpleConversation *conv, void *data)
+{
+	if (conv->logs == NULL)
+		return;
+	PurpleLog *log = conv->logs->data;
+	if (log == NULL)
+		return;
+	int s = socket(AF_UNIX, SOCK_DGRAM, 0);
+	if (s < 0)
+	{
+		purple_debug_warning("syncnotify", "socket: %m\n");
+		return;
+	}
+	char *dir = purple_log_get_log_dir(log->type, log->name, log->account);
+	const struct tm *tm = localtime(&log->time);
+	const char *tz = purple_escape_filename(purple_utf8_strftime("%Z", tm));
+	const char *date = purple_utf8_strftime("%Y-%m-%d.%H%M%S%z", tm);
+	char *filename = g_strdup_printf("%s%s.html", date, tz);
+	const char *path = g_build_filename(dir, filename, NULL);
+	g_free(dir);
+	g_free(filename);
+	ssize_t r = sendto(s, path, strlen(path), 0, &ADDR, SUN_LEN(&ADDR)+1);
+	if (r < 0 && errno != ENOENT && errno != ECONNREFUSED)
+		purple_debug_warning("syncnotify", "sendto: %m\n");
+	close(s);
+}
+
+static gboolean
+plugin_load(PurplePlugin *plugin)
+{
+	purple_signal_connect(purple_conversations_get_handle(), "conversation-created", plugin,
+	                    PURPLE_CALLBACK(conversation_created_cb), NULL);
+
+	return TRUE;
+}
+
+static gboolean
+plugin_unload(PurplePlugin *plugin)
+{
+	return TRUE;
+}
+
+static PurplePluginInfo info =
+{
+	PURPLE_PLUGIN_MAGIC,
+	PURPLE_MAJOR_VERSION,
+	PURPLE_MINOR_VERSION,
+	PURPLE_PLUGIN_STANDARD,                             /**< type           */
+	NULL,                                             /**< ui_requirement */
+	0,                                                /**< flags          */
+	NULL,                                             /**< dependencies   */
+	PURPLE_PRIORITY_DEFAULT,                            /**< priority       */
+
+	NOTIFY_PLUGIN_ID,                                 /**< id             */
+	N_("Dylex Notifier"),                              /**< name           */
+	DISPLAY_VERSION,                                  /**< version        */
+	                                                  /**  summary        */
+	N_("Pushes relevant event notifications."),
+	                                                  /**  description    */
+	N_("Pushes relevant event notifications."),
+	"Dylan Simon <dylan@dylex.net>",        /**< author         */
+	NULL,                                     /**< homepage       */
+
+	plugin_load,                                      /**< load           */
+	plugin_unload,                                    /**< unload         */
+	NULL,                                             /**< destroy        */
+
+	NULL,                                             /**< ui_info        */
+	NULL,                                             /**< extra_info     */
+	NULL,
+	NULL
+};
+
+static void
+init_plugin(PurplePlugin *plugin)
+{
+}
+
+PURPLE_INIT_PLUGIN(notify, init_plugin, info)
