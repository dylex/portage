diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000000..42193c7bd7
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,20 @@
+Makefile
+Makefile.in
+/aclocal.m4
+/autom4te.cache/
+/compile
+/config.cache
+/config.guess
+/config.h.in
+/config.log
+/config.status
+/config.sub
+/configure
+/depcomp
+/install-sh
+/intltool-*
+/ltmain.sh
+/missing
+/po/Makefile.in.in
+/po/Makefile.in.in.bak
+/test-driver
diff --git a/Makefile.am b/Makefile.am
index 587931147c..ef8b83604d 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -1,4 +1,4 @@
-EXTRA_DIST = \
+EXTRA_DIST = config.rpath  \
 		COPYRIGHT \
 		ChangeLog.API \
 		ChangeLog.win32 \
@@ -141,3 +141,5 @@ distuninstallcheck_listfiles = \
 
 DISTCLEANFILES= intltool-extract intltool-merge intltool-update \
 			package_revision_raw.txt
+
+ACLOCAL_AMFLAGS = -I m4
diff --git a/configure.ac b/configure.ac
index b8acd2a67b..9d890b5531 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1488,7 +1488,7 @@ AC_ARG_WITH([python],
 
 if test "x$enable_dbus" = "xyes" || test "x$enable_consoleui" = "xyes" ; then
 	if test -z "$PYTHON" -o "x$PYTHON" = "xyes"; then
-		AC_PATH_PROG([PYTHON], [python], [no])
+	AC_PATH_PROG([PYTHON], [python], [no])
 	fi
 
 	if test x"$PYTHON" = x"no" ; then
diff --git a/finch/Makefile.am b/finch/Makefile.am
index 95976e8d49..8d159e333f 100644
--- a/finch/Makefile.am
+++ b/finch/Makefile.am
@@ -25,6 +25,7 @@ finch_SOURCES = \
 	gntft.c \
 	finch.c \
 	gntidle.c \
+	gntimhtml.c \
 	gntlog.c \
 	gntmedia.c \
 	gntnotify.c \
@@ -47,6 +48,7 @@ finch_headers = \
 	gntft.h \
 	finch.h \
 	gntidle.h \
+	gntimhtml.h \
 	gntlog.h \
 	gntmedia.h \
 	gntnotify.h \
diff --git a/finch/gntblist.c b/finch/gntblist.c
index b2c62c55d8..c8af2dba27 100644
--- a/finch/gntblist.c
+++ b/finch/gntblist.c
@@ -1322,6 +1322,13 @@ toggle_show_offline(GntMenuItem *item, gpointer buddy)
 }
 
 static void
+toggle_log(GntMenuItem *item, gpointer buddy)
+{
+	purple_blist_node_set_bool(buddy, "log",
+			!purple_blist_node_get_bool(buddy, "log"));
+}
+
+static void
 create_buddy_menu(GntMenu *menu, PurpleBuddy *buddy)
 {
 	PurpleAccount *account;
@@ -1361,6 +1368,11 @@ create_buddy_menu(GntMenu *menu, PurpleBuddy *buddy)
 	gnt_menuitem_set_callback(item, toggle_show_offline, buddy);
 	gnt_menu_add_item(menu, item);
 
+	item = gnt_menuitem_check_new(_("Always log"));
+	gnt_menuitem_check_set_checked(GNT_MENU_ITEM_CHECK(item), purple_blist_node_get_bool((PurpleBlistNode*)buddy, "log"));
+	gnt_menuitem_set_callback(item, toggle_log, buddy);
+	gnt_menu_add_item(menu, item);
+
 	/* Protocol actions */
 	append_proto_menu(menu,
 			purple_account_get_connection(purple_buddy_get_account(buddy)),
@@ -2764,6 +2776,55 @@ block_select(GntMenuItem *item, gpointer n)
 						NULL);
 }
 
+static void
+privacy_select_cb(gpointer data, PurpleRequestFields *fields)
+{
+	PurpleAccount *account = purple_request_fields_get_account(fields, "account");
+	if (account) {
+		account->perm_deny = purple_request_fields_get_choice(fields, "privacy");
+		serv_set_permit_deny(purple_account_get_connection(account));
+	}
+}
+
+static void
+privacy_select(GntMenuItem *item, gpointer n)
+{
+	PurpleRequestFields *fields;
+	PurpleRequestFieldGroup *group;
+	PurpleRequestField *field;
+
+	fields = purple_request_fields_new();
+
+	group = purple_request_field_group_new(NULL);
+	purple_request_fields_add_group(fields, group);
+
+	field = purple_request_field_account_new("account", _("Account"), NULL);
+	purple_request_field_set_type_hint(field, "account");
+	purple_request_field_set_visible(field,
+		(purple_connections_get_all() != NULL &&
+		 purple_connections_get_all()->next != NULL));
+	purple_request_field_set_required(field, TRUE);
+	purple_request_field_group_add_field(group, field);
+
+	field = purple_request_field_choice_new("privacy", _("Privacy"), 1);
+	/* these are assumed to be in PurplePrivacyType order */
+	purple_request_field_choice_add(field, _("Allow all"));
+	purple_request_field_choice_add(field, _("Allow only buddy list"));
+	purple_request_field_choice_add(field, _("Allow only unblocked"));
+	purple_request_field_choice_add(field, _("Deny all"));
+	purple_request_field_choice_add(field, _("Deny only blocked"));
+	purple_request_field_group_add_field(group, field);
+
+	purple_request_fields(purple_get_blist(), _("Set"),
+						NULL,
+						_("Select which users may contact you on the specified account."),
+						fields,
+						_("OK"), G_CALLBACK(privacy_select_cb),
+						_("Cancel"), NULL,
+						NULL, NULL, NULL,
+						NULL);
+}
+
 /* send_im_select* -- Xerox */
 static void
 send_im_select_cb(gpointer data, PurpleRequestFields *fields)
@@ -3012,6 +3073,11 @@ create_menu(void)
 	gnt_menu_add_item(GNT_MENU(sub), item);
 	gnt_menuitem_set_callback(GNT_MENU_ITEM(item), block_select, NULL);
 
+	item = gnt_menuitem_new(_("Privacy..."));
+	gnt_menuitem_set_id(GNT_MENU_ITEM(item), "privacy");
+	gnt_menu_add_item(GNT_MENU(sub), item);
+	gnt_menuitem_set_callback(GNT_MENU_ITEM(item), privacy_select, NULL);
+
 	item = gnt_menuitem_new(_("Join Chat..."));
 	gnt_menuitem_set_id(GNT_MENU_ITEM(item), "join-chat");
 	gnt_menu_add_item(GNT_MENU(sub), item);
diff --git a/finch/gntconv.c b/finch/gntconv.c
index 04c882857a..45e01fd38e 100644
--- a/finch/gntconv.c
+++ b/finch/gntconv.c
@@ -44,6 +44,7 @@
 #include "gntrequest.h"
 #include "gntsound.h"
 #include "gntstatus.h"
+#include "gntimhtml.h"
 
 #include "gnt.h"
 #include "gntbox.h"
@@ -150,7 +151,7 @@ entry_key_pressed(GntWidget *w, FinchConv *ggconv)
 		char *error = NULL, *escape;
 
 		escape = g_markup_escape_text(cmdline, -1);
-		status = purple_cmd_do_command(conv, cmdline, escape, &error);
+		status = purple_cmd_do_command(conv, escape, cmdline, &error);
 		g_free(escape);
 
 		switch (status)
@@ -906,7 +907,7 @@ finch_write_common(PurpleConversation *conv, const char *who, const char *messag
 		PurpleMessageFlags flags, time_t mtime)
 {
 	FinchConv *ggconv = FINCH_GET_DATA(conv);
-	char *strip, *newline;
+	char *strip;
 	GntTextFormatFlags fl = 0;
 	int pos;
 
@@ -933,7 +934,7 @@ finch_write_common(PurpleConversation *conv, const char *who, const char *messag
 		if (!mtime)
 			time(&mtime);
 		gnt_text_view_append_text_with_flags(GNT_TEXT_VIEW(ggconv->tv),
-					purple_utf8_strftime("(%H:%M:%S)", localtime(&mtime)), gnt_color_pair(color_timestamp));
+					purple_utf8_strftime(purple_prefs_get_string("/finch/conversations/timestamp_fmt"), localtime(&mtime)), gnt_color_pair(color_timestamp));
 	}
 
 	gnt_text_view_append_text_with_flags(GNT_TEXT_VIEW(ggconv->tv), " ", GNT_TEXT_FLAG_NORMAL);
@@ -976,14 +977,7 @@ finch_write_common(PurpleConversation *conv, const char *who, const char *messag
 	if (flags & PURPLE_MESSAGE_ERROR)
 		fl |= GNT_TEXT_FLAG_BOLD;
 
-	/* XXX: Remove this workaround when textview can parse messages. */
-	newline = purple_strdup_withhtml(message);
-	strip = purple_markup_strip_html(newline);
-	gnt_text_view_append_text_with_flags(GNT_TEXT_VIEW(ggconv->tv),
-				strip, fl);
-
-	g_free(newline);
-	g_free(strip);
+	gnt_imhtml_append_markup(GNT_TEXT_VIEW(ggconv->tv), message, fl);
 
 	if (purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_IM &&
 			purple_conv_im_get_typing_state(PURPLE_CONV_IM(conv)) == PURPLE_TYPING) {
diff --git a/finch/gntimhtml.c b/finch/gntimhtml.c
new file mode 100644
index 0000000000..56dc007580
--- /dev/null
+++ b/finch/gntimhtml.c
@@ -0,0 +1,477 @@
+/*
+* @file gntimhtml.c GNT IMHtml
+* @ingroup finch
+*/
+
+/* finch
+*
+* Finch is the legal property of its developers, whose names are too numerous
+* to list here.  Please refer to the COPYRIGHT file distributed with this
+* source distribution.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02111-1301  USA
+*/
+
+#include "gnt.h"
+#include "gnttextview.h"
+#include "gntimhtml.h"
+
+#include "util.h"
+#include <string.h>
+#include <ctype.h>
+
+/******************************************************************************
+* GntIMHtml API
+*****************************************************************************/
+
+/* This could be a separate class, but at present there's no need.
+* Most of the following was copied from pidgin/gtkimhtml */
+
+#define VALID_TAG(x)	if (!g_ascii_strncasecmp (string, x ">", strlen (x ">"))) {	\
+			*tag = g_strndup (string, strlen (x));		\
+			*len = strlen (x) + 1;				\
+			return TRUE;					\
+		}							\
+		(*type)++
+
+#define VALID_OPT_TAG(x) if (!g_ascii_strncasecmp (string, x " ", strlen (x " "))) {	\
+				const gchar *c = string + strlen (x " ");	\
+				gchar e = '"';					\
+				gboolean quote = FALSE;				\
+				while (*c) {					\
+					if (*c == '"' || *c == '\'') {		\
+						if (quote && (*c == e))		\
+							quote = !quote;		\
+						else if (!quote) {		\
+							quote = !quote;		\
+							e = *c;			\
+						}				\
+					} else if (!quote && (*c == '>'))	\
+						break;				\
+					c++;					\
+				}						\
+				if (*c) {					\
+					*tag = g_strndup (string, c - string);	\
+					*len = c - string + 1;			\
+					return TRUE;				\
+				}						\
+			}							\
+			(*type)++
+
+static gboolean
+gnt_imhtml_is_tag (const gchar *string,
+	   gchar      **tag,
+	   gint        *len,
+	   gint        *type)
+{
+	char *close;
+	*type = 1;
+
+	if (!(close = strchr (string, '>')))
+		return FALSE;
+
+	VALID_TAG ("B");
+	VALID_TAG ("BOLD");
+	VALID_TAG ("/B");
+	VALID_TAG ("/BOLD");
+	VALID_TAG ("I");
+	VALID_TAG ("ITALIC");
+	VALID_TAG ("/I");
+	VALID_TAG ("/ITALIC");
+	VALID_TAG ("U");
+	VALID_TAG ("UNDERLINE");
+	VALID_TAG ("/U");
+	VALID_TAG ("/UNDERLINE");
+	VALID_TAG ("S");
+	VALID_TAG ("STRIKE");
+	VALID_TAG ("/S");
+	VALID_TAG ("/STRIKE");
+	VALID_TAG ("SUB");
+	VALID_TAG ("/SUB");
+	VALID_TAG ("SUP");
+	VALID_TAG ("/SUP");
+	VALID_TAG ("PRE");
+	VALID_TAG ("/PRE");
+	VALID_TAG ("TITLE");
+	VALID_TAG ("/TITLE");
+	VALID_TAG ("BR");
+	VALID_TAG ("HR");
+	VALID_TAG ("/FONT");
+	VALID_TAG ("/A");
+	VALID_TAG ("P");
+	VALID_TAG ("/P");
+	VALID_TAG ("H3");
+	VALID_TAG ("/H3");
+	VALID_TAG ("HTML");
+	VALID_TAG ("/HTML");
+	VALID_TAG ("BODY");
+	VALID_TAG ("/BODY");
+	VALID_TAG ("FONT");
+	VALID_TAG ("HEAD");
+	VALID_TAG ("/HEAD");
+	VALID_TAG ("BINARY");
+	VALID_TAG ("/BINARY");
+
+	VALID_OPT_TAG ("HR");
+	VALID_OPT_TAG ("FONT");
+	VALID_OPT_TAG ("BODY");
+	VALID_OPT_TAG ("A");
+	VALID_OPT_TAG ("IMG");
+	VALID_OPT_TAG ("P");
+	VALID_OPT_TAG ("H3");
+	VALID_OPT_TAG ("HTML");
+
+	VALID_TAG ("CITE");
+	VALID_TAG ("/CITE");
+	VALID_TAG ("EM");
+	VALID_TAG ("/EM");
+	VALID_TAG ("STRONG");
+	VALID_TAG ("/STRONG");
+
+	VALID_OPT_TAG ("SPAN");
+	VALID_TAG ("/SPAN");
+	VALID_TAG ("BR/"); /* hack until gtkimhtml handles things better */
+	VALID_TAG ("IMG");
+	VALID_TAG("SPAN");
+	VALID_OPT_TAG("BR");
+
+	if (!g_ascii_strncasecmp(string, "!--", strlen ("!--"))) {
+		gchar *e = strstr (string + strlen("!--"), "-->");
+		if (e) {
+			*len = e - string + strlen ("-->");
+			*tag = g_strndup (string + strlen ("!--"), *len - strlen ("!---->"));
+			return TRUE;
+		}
+	}
+
+	*type = -1;
+	*len = close - string + 1;
+	*tag = g_strndup(string, *len - 1);
+	return TRUE;
+}
+
+static gchar*
+gnt_imhtml_get_html_opt (gchar       *tag,
+		 const gchar *opt)
+{
+	gchar *t = tag;
+	gchar *e, *a;
+	gchar *val;
+	gint len;
+	const gchar *c;
+	GString *ret;
+
+	while (g_ascii_strncasecmp (t, opt, strlen (opt))) {
+		gboolean quote = FALSE;
+		if (*t == '\0') break;
+		while (*t && !((*t == ' ') && !quote)) {
+			if (*t == '\"')
+				quote = ! quote;
+			t++;
+		}
+		while (*t && (*t == ' ')) t++;
+	}
+
+	if (!g_ascii_strncasecmp (t, opt, strlen (opt))) {
+		t += strlen (opt);
+	} else {
+		return NULL;
+	}
+
+	if ((*t == '\"') || (*t == '\'')) {
+		e = a = ++t;
+		while (*e && (*e != *(t - 1))) e++;
+		if  (*e == '\0') {
+			return NULL;
+		} else
+			val = g_strndup(a, e - a);
+	} else {
+		e = a = t;
+		while (*e && !isspace ((gint) *e)) e++;
+		val = g_strndup(a, e - a);
+	}
+
+	ret = g_string_new("");
+	e = val;
+	while(*e) {
+		if((c = purple_markup_unescape_entity(e, &len))) {
+			ret = g_string_append(ret, c);
+			e += len;
+		} else {
+			gunichar uni = g_utf8_get_char(e);
+			ret = g_string_append_unichar(ret, uni);
+			e = g_utf8_next_char(e);
+		}
+	}
+
+	g_free(val);
+
+	return g_string_free(ret, FALSE);
+}
+
+static int gnt_imhtml_fgcolor(const char *color)
+{
+	if (!g_ascii_strcasecmp(color, "red"))
+		return gnt_color_pair(GNT_COLOR_RED);
+	else if (!g_ascii_strcasecmp(color, "green"))
+		return gnt_color_pair(GNT_COLOR_GREEN);
+	else if (!g_ascii_strcasecmp(color, "yellow"))
+		return gnt_color_pair(GNT_COLOR_YELLOW);
+	else if (!g_ascii_strcasecmp(color, "blue"))
+		return gnt_color_pair(GNT_COLOR_BLUE);
+	else if (!g_ascii_strcasecmp(color, "magenta"))
+		return gnt_color_pair(GNT_COLOR_MAGENTA);
+	else if (!g_ascii_strcasecmp(color, "cyan"))
+		return gnt_color_pair(GNT_COLOR_CYAN);
+	else if (!g_ascii_strcasecmp(color, "white"))
+		return gnt_color_pair(GNT_COLOR_WHITE);
+	else if (!g_ascii_strcasecmp(color, "black"))
+		return gnt_color_pair(GNT_COLOR_BLACK);
+	return 0;
+}
+
+void gnt_imhtml_append_markup(GntTextView *view, const char *text, GntTextFormatFlags orig_flags)
+{
+	gchar *ws;
+	gint wpos=0;
+	const gchar *c;
+
+	guint	bold = 0,
+		underline = 0;
+	gchar *href = NULL;
+	gboolean br = FALSE;
+
+	GntTextFormatFlags flags = orig_flags;
+	GSList *fonts = NULL;
+
+	g_return_if_fail (view != NULL);
+	g_return_if_fail (GNT_IS_TEXT_VIEW (view));
+	g_return_if_fail (text != NULL);
+	c = text;
+	ws = g_malloc(strlen(text) + 1);
+	ws[0] = 0;
+
+	#define ADD_TEXT if (wpos) { ws[wpos] = '\0'; gnt_text_view_append_text_with_flags(view, ws, flags); ws[wpos = 0] = '\0'; }
+
+	while (*c)
+	{
+		gchar *tag;
+		gint tlen, type;
+		const gchar *amp;
+		if (*c == '<' && gnt_imhtml_is_tag (c + 1, &tag, &tlen, &type)) {
+				c++;
+				ws[wpos] = '\0';
+				br = FALSE;
+				switch (type)
+				{
+					/* these random numbers are awful */
+					case 1:		/* B */
+					case 2:		/* BOLD */
+					case 54:	/* STRONG */
+					case 52:	/* EM */
+						if (!bold++)
+						{
+							ADD_TEXT;
+							flags |= GNT_TEXT_FLAG_BOLD;
+						}
+						break;
+					case 3:		/* /B */
+					case 4:		/* /BOLD */
+					case 55:	/* /STRONG */
+					case 53:	/* /EM */
+						if (bold && !--bold)
+						{
+							ADD_TEXT;
+							flags &= ~GNT_TEXT_FLAG_BOLD | orig_flags;
+						}
+						break;
+					case 5:		/* I */
+					case 6:		/* ITALIC */
+					case 9:		/* U */
+					case 10:	/* UNDERLINE */
+						ADD_TEXT;
+						underline++;
+						flags ^= GNT_TEXT_FLAG_UNDERLINE;
+						break;
+					case 7:		/* /I */
+					case 8:		/* /ITALIC */
+					case 11:	/* /U */
+					case 12:	/* /UNDERLINE */
+						if (underline)
+						{
+							ADD_TEXT;
+							underline--;
+							flags ^= GNT_TEXT_FLAG_UNDERLINE;
+						}
+						break;
+					case 17:	/* SUB */
+						ws[wpos++] = '_';
+						break;
+					case 19:	/* SUP */
+						ws[wpos++] = '^';
+						break;
+					case 25:	/* BR */
+					case 58:	/* BR/ */
+					case 61:	/* BR (opt) */
+					case 26:        /* HR */
+					case 42:        /* HR (opt) */
+						ws[wpos++] = '\n';
+						br = TRUE;
+						break;
+					case 37:	/* FONT */
+						fonts = g_slist_prepend(fonts, GINT_TO_POINTER(flags));
+						break;
+					case 43:	/* FONT (opt) */
+						fonts = g_slist_prepend(fonts, GINT_TO_POINTER(flags));
+						{
+							gchar *color;
+							color = gnt_imhtml_get_html_opt (tag, "COLOR=");
+
+							if (color)
+							{
+								ADD_TEXT;
+								flags &= ~A_COLOR;
+								flags |= gnt_imhtml_fgcolor(color);
+								g_free(color);
+							}
+						}
+						break;
+					case 27:	/* /FONT */
+						if (fonts)
+						{
+							ADD_TEXT;
+							flags &= ~A_COLOR;
+							flags |= GPOINTER_TO_INT(fonts->data) & A_COLOR;
+							fonts = g_slist_remove (fonts, fonts->data);
+
+						}
+						break;
+					case 45:	/* A (opt) */
+						ADD_TEXT;
+						if (href)
+							g_free(href);
+						href = gnt_imhtml_get_html_opt(tag, "HREF=");
+						flags ^= GNT_TEXT_FLAG_UNDERLINE;
+						break;
+					case 28:        /* /A    */
+						ADD_TEXT;
+						flags ^= GNT_TEXT_FLAG_UNDERLINE;
+						if (href)
+						{
+							// ws[wpos++] = ' ';
+							ws[wpos++] = '[';
+							strcpy(&ws[wpos], href);
+							wpos += strlen(href);
+							ws[wpos++] = ']';
+							g_free(href);
+							href = NULL;
+						}
+						break;
+					case 47:	/* P (opt) */
+					case 48:	/* H3 (opt) */
+					case 49:	/* HTML (opt) */
+					case 50:	/* CITE */
+					case 51:	/* /CITE */
+					case 56:	/* SPAN (opt) */
+						fonts = g_slist_prepend(fonts, GINT_TO_POINTER(flags));
+						{
+							gchar *style, *color = NULL, *textdec = NULL, *weight = NULL;
+							style = gnt_imhtml_get_html_opt (tag, "style=");
+
+							if (style)
+							{
+								color = purple_markup_get_css_property (style, "color");
+								textdec = purple_markup_get_css_property (style, "text-decoration");
+								weight = purple_markup_get_css_property (style, "font-weight");
+							}
+
+							if (color)
+							{
+								ADD_TEXT;
+								flags &= ~A_COLOR;
+								flags |= gnt_imhtml_fgcolor(color);
+								g_free(color);
+							}
+							if (textdec)
+							{
+								if (!g_ascii_strcasecmp(textdec, "underline"))
+								{
+									ADD_TEXT;
+									flags ^= GNT_TEXT_FLAG_UNDERLINE;
+								}
+								g_free(textdec);
+							}
+							if (weight)
+							{
+								if (!g_ascii_strcasecmp(weight, "normal"))
+								{
+									flags &= ~GNT_TEXT_FLAG_BOLD;
+									flags |= orig_flags & GNT_TEXT_FLAG_BOLD;
+								}
+								else if (!g_ascii_strcasecmp(weight, "bold") || !g_ascii_strcasecmp(weight, "bolder"))
+									flags |= GNT_TEXT_FLAG_BOLD;
+								else if (!g_ascii_strcasecmp(weight, "lighter"))
+									flags &= ~GNT_TEXT_FLAG_BOLD;
+								g_free(weight);
+							}
+
+							g_free(style);
+						}
+						break;
+					case 57:	/* /SPAN */
+						if (fonts)
+						{
+							ADD_TEXT;
+							flags = GPOINTER_TO_INT(fonts->data);
+							fonts = g_slist_remove(fonts, fonts->data);
+						}
+						break;
+					case 62:	/* comment */
+						ADD_TEXT;
+						break;
+					default:
+						break;
+				}
+				c += tlen;
+				g_free(tag); /* This was allocated back in VALID_TAG() */
+			} else if (*c == '&' && (amp = purple_markup_unescape_entity(c, &tlen))) {
+				br = FALSE;
+				while(*amp) {
+					ws [wpos++] = *amp++;
+				}
+				c += tlen;
+			} else if (*c == '\n') {
+				if (!br) {  /* Don't insert a space immediately after an HTML break */
+					/* A newline is defined by HTML as whitespace, which means we have to replace it with a word boundary.
+					 * word breaks vary depending on the language used, so the correct thing to do is to use Pango to determine
+					 * what language this is, determine the proper word boundary to use, and insert that. I'm just going to insert
+					 * a space instead.  What are the non-English speakers going to do?  Complain in a language I'll understand?
+					 * Bu-wahaha! */
+					ws[wpos++] = ' ';
+				}
+				c++;
+			} else {
+				br = FALSE;
+				ws [wpos++] = *c++;
+			}
+		}
+		ADD_TEXT;
+
+		while (fonts)
+			fonts = g_slist_remove(fonts, fonts->data);
+
+		g_free(ws);
+}
+
diff --git a/finch/gntimhtml.h b/finch/gntimhtml.h
new file mode 100644
index 0000000000..7760353951
--- /dev/null
+++ b/finch/gntimhtml.h
@@ -0,0 +1,48 @@
+/**
+ * @file gntimhtml.h GNT IM/HTML rendering component
+ * @ingroup finch
+ */
+
+/* finch
+ *
+ * Finch is the legal property of its developers, whose names are too numerous
+ * to list here.  Please refer to the COPYRIGHT file distributed with this
+ * source distribution.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02111-1301  USA
+ */
+#ifndef _GNT_IMHTML_H
+#define _GNT_IMHTML_H
+
+#include <gnt.h>
+#include "gnttextview.h"
+
+/**************************************************************************
+ * @name GNT IM/HTML rendering component API
+ **************************************************************************/
+/*@{*/
+
+/**
+ * Inserts HTML formatted text to a GNT Textview.
+ *
+ * @param imhtml  The GNT Textview.
+ * @param text    The formatted text to append.
+ * @param flags  The text-flags to apply to the new text.
+ */
+void gnt_imhtml_append_markup(GntTextView *view, const char *text, GntTextFormatFlags flags);
+
+/*@}*/
+
+#endif /* _GNT_IMHTML_H */
diff --git a/finch/gntnotify.c b/finch/gntnotify.c
index f32650d2b5..081490a64d 100644
--- a/finch/gntnotify.c
+++ b/finch/gntnotify.c
@@ -93,7 +93,7 @@ finch_notify_common(PurpleNotifyType ntype, PurpleNotifyMsgType msgtype,
 			gnt_text_view_set_flag(GNT_TEXT_VIEW(msg), GNT_TEXT_VIEW_TOP_ALIGN | GNT_TEXT_VIEW_NO_SCROLL);
 
 			plain = purple_markup_strip_html(secondary);
-			if (!gnt_util_parse_xhtml_to_textview(secondary, GNT_TEXT_VIEW(msg)))
+			if (!gnt_util_parse_xhtml_to_textview(secondary, GNT_TEXT_VIEW(msg), 0))
 				gnt_text_view_append_text_with_flags(GNT_TEXT_VIEW(msg), plain, sf);
 
 			gnt_text_view_attach_scroll_widget(GNT_TEXT_VIEW(msg), button);
@@ -348,7 +348,7 @@ finch_notify_userinfo(PurpleConnection *gc, const char *who, PurpleNotifyUserInf
 		gnt_widget_get_size(GNT_WIDGET(msg), &tvw, &tvh);
 
 		gnt_text_view_clear(msg);
-		if (!gnt_util_parse_xhtml_to_textview(info, msg))
+		if (!gnt_util_parse_xhtml_to_textview(info, msg, 0))
 			gnt_text_view_append_text_with_flags(msg, strip, GNT_TEXT_FLAG_NORMAL);
 		gnt_text_view_scroll(msg, 0);
 		gnt_util_get_text_bound(strip, &ntvw, &ntvh);
diff --git a/finch/gntprefs.c b/finch/gntprefs.c
index 308962d895..673ca5c910 100644
--- a/finch/gntprefs.c
+++ b/finch/gntprefs.c
@@ -53,11 +53,11 @@ void finch_prefs_init()
 
 	purple_prefs_add_none("/finch/conversations");
 	purple_prefs_add_bool("/finch/conversations/timestamps", TRUE);
+	purple_prefs_add_string("/finch/conversations/timestamp_fmt", "(%H:%M:%S)");
 	purple_prefs_add_bool("/finch/conversations/notify_typing", FALSE);
 
 	purple_prefs_add_none("/finch/filelocations");
 	purple_prefs_add_path("/finch/filelocations/last_save_folder", "");
-	purple_prefs_add_path("/finch/filelocations/last_save_folder", "");
 }
 
 void finch_prefs_update_old()
@@ -192,6 +192,7 @@ static Prefs blist[] =
 static Prefs convs[] =
 {
 	{PURPLE_PREF_BOOLEAN, "/finch/conversations/timestamps", N_("Show Timestamps"), NULL},
+	{PURPLE_PREF_STRING, "/finch/conversations/timestamp_fmt", N_("Timestamp Format"), NULL},
 	{PURPLE_PREF_BOOLEAN, "/finch/conversations/notify_typing", N_("Notify buddies when you are typing"), NULL},
 	{PURPLE_PREF_NONE, NULL, NULL, NULL}
 };
diff --git a/finch/libgnt/Makefile.am b/finch/libgnt/Makefile.am
index 07533e2474..b356273993 100644
--- a/finch/libgnt/Makefile.am
+++ b/finch/libgnt/Makefile.am
@@ -10,8 +10,8 @@ noinst_HEADERS = gntinternal.h
 
 BUILT_SOURCES = gntmarshal.h
 
+nodist_libgnt_la_SOURCES = gntmarshal.c
 libgnt_la_SOURCES = \
-	gntmarshal.c \
 	gntwidget.c \
 	gntbindable.c \
 	gntbox.c \
@@ -53,7 +53,6 @@ libgnt_la_headers = \
 	gntkeys.h \
 	gntlabel.h \
 	gntline.h \
-	gntmarshal.h \
 	gntmenu.h \
 	gntmenuitem.h \
 	gntmenuitemcheck.h \
@@ -80,6 +79,7 @@ gntmarshal.h: $(srcdir)/genmarshal
 	glib-genmarshal --prefix=gnt_closure_marshal --header $(srcdir)/genmarshal > $@
 
 libgnt_laincludedir=$(includedir)/gnt
+nodist_libgnt_lainclude_HEADERS = gntmarshal.h
 libgnt_lainclude_HEADERS = \
 	$(libgnt_la_headers)
 
diff --git a/finch/libgnt/gntcolors.c b/finch/libgnt/gntcolors.c
index 9e271433a0..f51d5e2a4e 100644
--- a/finch/libgnt/gntcolors.c
+++ b/finch/libgnt/gntcolors.c
@@ -38,22 +38,26 @@
 #include <string.h>
 
 static gboolean hascolors;
+static int bg_color = -1;
 static int custom_type = GNT_COLORS;
+#define MAX_COLORS 256
 static struct
 {
+	gboolean i;
 	short r, g, b;
-} colors[GNT_TOTAL_COLORS];
-
-static void
-backup_colors(void)
-{
-	short i;
-	for (i = 0; i < GNT_TOTAL_COLORS; i++)
-	{
-		color_content(i, &colors[i].r,
-				&colors[i].g, &colors[i].b);
-	}
-}
+	gboolean o;
+	short or, og, ob;
+} colors[MAX_COLORS] = {
+	/* assume default colors */
+	{ 1, 0, 0, 0, 0 },
+	{ 1, 1000, 0, 0, 0 },
+	{ 1, 0, 1000, 0, 0 },
+	{ 1, 1000, 1000, 0, 0 },
+	{ 1, 0, 0, 1000, 0 },
+	{ 1, 1000, 0, 1000, 0 },
+	{ 1, 0, 1000, 1000, 0 },
+	{ 1, 1000, 1000, 1000, 0 }
+};
 
 static gboolean
 can_use_custom_color(void)
@@ -65,10 +69,10 @@ static void
 restore_colors(void)
 {
 	short i;
-	for (i = 0; i < GNT_TOTAL_COLORS; i++)
+	for (i = 0; i < MAX_COLORS; i++)
 	{
-		init_color(i, colors[i].r,
-				colors[i].g, colors[i].b);
+		if (colors[i].o)
+			init_color(i, colors[i].or, colors[i].og, colors[i].ob);
 	}
 }
 
@@ -76,6 +80,7 @@ void gnt_init_colors()
 {
 	static gboolean init = FALSE;
 	int defaults;
+	int c;
 
 	if (init)
 		return;
@@ -86,53 +91,26 @@ void gnt_init_colors()
 		return;
 	defaults = use_default_colors();
 
-	if (can_use_custom_color())
-	{
-		backup_colors();
-
-		/* Do some init_color()s */
-		init_color(GNT_COLOR_BLACK, 0, 0, 0);
-		init_color(GNT_COLOR_RED, 1000, 0, 0);
-		init_color(GNT_COLOR_GREEN, 0, 1000, 0);
-		init_color(GNT_COLOR_BLUE, 250, 250, 700);
-		init_color(GNT_COLOR_WHITE, 1000, 1000, 1000);
-		init_color(GNT_COLOR_GRAY, 699, 699, 699);
-		init_color(GNT_COLOR_DARK_GRAY, 256, 256, 256);
-
-		/* Now some init_pair()s */
-		init_pair(GNT_COLOR_NORMAL, GNT_COLOR_BLACK, GNT_COLOR_WHITE);
-		init_pair(GNT_COLOR_HIGHLIGHT, GNT_COLOR_WHITE, GNT_COLOR_BLUE);
-		init_pair(GNT_COLOR_SHADOW, GNT_COLOR_BLACK, GNT_COLOR_DARK_GRAY);
-
-		init_pair(GNT_COLOR_TITLE, GNT_COLOR_WHITE, GNT_COLOR_BLUE);
-		init_pair(GNT_COLOR_TITLE_D, GNT_COLOR_WHITE, GNT_COLOR_GRAY);
-
-		init_pair(GNT_COLOR_TEXT_NORMAL, GNT_COLOR_WHITE, GNT_COLOR_BLUE);
-		init_pair(GNT_COLOR_HIGHLIGHT_D, GNT_COLOR_BLACK, GNT_COLOR_GRAY);
-		init_pair(GNT_COLOR_DISABLED, GNT_COLOR_GRAY, GNT_COLOR_WHITE);
-		init_pair(GNT_COLOR_URGENT, GNT_COLOR_WHITE, GNT_COLOR_RED);
-	}
-	else
-	{
-		int bg;
-
-		if (defaults == OK) {
-			init_pair(GNT_COLOR_NORMAL, -1, -1);
-			bg = -1;
-		} else {
-			init_pair(GNT_COLOR_NORMAL, COLOR_BLACK, COLOR_WHITE);
-			bg = COLOR_WHITE;
-		}
-		init_pair(GNT_COLOR_DISABLED, COLOR_YELLOW, bg);
-		init_pair(GNT_COLOR_URGENT, COLOR_GREEN, bg);
-
-		init_pair(GNT_COLOR_HIGHLIGHT, COLOR_WHITE, COLOR_BLUE);
-		init_pair(GNT_COLOR_SHADOW, COLOR_BLACK, COLOR_BLACK);
-		init_pair(GNT_COLOR_TITLE, COLOR_WHITE, COLOR_BLUE);
-		init_pair(GNT_COLOR_TITLE_D, COLOR_WHITE, COLOR_BLACK);
-		init_pair(GNT_COLOR_TEXT_NORMAL, COLOR_WHITE, COLOR_BLUE);
-		init_pair(GNT_COLOR_HIGHLIGHT_D, COLOR_CYAN, COLOR_BLACK);
+	if (defaults == OK) {
+		bg_color = -1;
+		init_pair(GNT_COLOR_NORMAL, -1, bg_color);
+	} else {
+		bg_color = COLOR_WHITE;
+		init_pair(GNT_COLOR_NORMAL, COLOR_BLACK, bg_color);
 	}
+
+	for (c = 1; c < GNT_COLOR_NORMAL; c ++)
+		init_pair(c, c, bg_color);
+
+	init_pair(GNT_COLOR_DISABLED, COLOR_YELLOW, bg_color);
+	init_pair(GNT_COLOR_URGENT, COLOR_GREEN, bg_color);
+
+	init_pair(GNT_COLOR_HIGHLIGHT, COLOR_WHITE, COLOR_BLUE);
+	init_pair(GNT_COLOR_SHADOW, COLOR_BLACK, COLOR_BLACK);
+	init_pair(GNT_COLOR_TITLE, COLOR_WHITE, COLOR_BLUE);
+	init_pair(GNT_COLOR_TITLE_D, COLOR_WHITE, COLOR_BLACK);
+	init_pair(GNT_COLOR_TEXT_NORMAL, COLOR_WHITE, COLOR_BLUE);
+	init_pair(GNT_COLOR_HIGHLIGHT_D, COLOR_CYAN, COLOR_BLACK);
 }
 
 void
@@ -147,31 +125,34 @@ int
 gnt_colors_get_color(char *key)
 {
 	int color;
-	gboolean custom = can_use_custom_color();
 
 	key = g_strstrip(key);
 
 	if (strcmp(key, "black") == 0)
-		color = custom ? GNT_COLOR_BLACK : COLOR_BLACK;
+		color = COLOR_BLACK;
 	else if (strcmp(key, "red") == 0)
-		color = custom ? GNT_COLOR_RED : COLOR_RED;
+		color = COLOR_RED;
 	else if (strcmp(key, "green") == 0)
-		color = custom ? GNT_COLOR_GREEN : COLOR_GREEN;
+		color = COLOR_GREEN;
+	else if (strcmp(key, "yellow") == 0)
+		color = COLOR_YELLOW;
 	else if (strcmp(key, "blue") == 0)
-		color = custom ? GNT_COLOR_BLUE : COLOR_BLUE;
-	else if (strcmp(key, "white") == 0)
-		color = custom ? GNT_COLOR_WHITE : COLOR_WHITE;
-	else if (strcmp(key, "gray") == 0 || strcmp(key, "grey") == 0)
-		color = custom ? GNT_COLOR_GRAY : COLOR_YELLOW;  /* eh? */
-	else if (strcmp(key, "darkgray") == 0 || strcmp(key, "darkgrey") == 0)
-		color = custom ? GNT_COLOR_DARK_GRAY : COLOR_BLACK;
+		color = COLOR_BLUE;
 	else if (strcmp(key, "magenta") == 0)
 		color = COLOR_MAGENTA;
 	else if (strcmp(key, "cyan") == 0)
 		color = COLOR_CYAN;
+	else if (strcmp(key, "white") == 0)
+		color = COLOR_WHITE;
 	else if (strcmp(key, "default") == 0)
 		color = -1;
 	else {
+		if (strncmp(key, "color", 5) == 0)
+		{
+			color = atoi(&key[5]);
+			if (color > 0 && color < COLORS && color < MAX_COLORS)
+				return color;
+		}
 		g_warning("Invalid color name: %s\n", key);
 		color = -EINVAL;
 	}
@@ -213,7 +194,17 @@ void gnt_colors_parse(GKeyFile *kfile)
 					continue;
 				}
 
-				init_color(color, r, g, b);
+				if (!colors[color].o)
+				{
+					colors[color].o = color_content(color, &colors[color].or, &colors[color].og, &colors[color].ob) != ERR;
+				}
+				if (init_color(color, r, g, b) != ERR)
+				{
+					colors[color].i = 1;
+					colors[color].r = r;
+					colors[color].g = g;
+					colors[color].b = b;
+				}
 			}
 			g_strfreev(list);
 		}
@@ -304,6 +295,8 @@ int gnt_color_pair(int pair)
 
 int gnt_color_add_pair(int fg, int bg)
 {
+	if (bg == -1)
+		bg = bg_color;
 	init_pair(custom_type, fg, bg);
 	return custom_type++;
 }
diff --git a/finch/libgnt/gntcolors.h b/finch/libgnt/gntcolors.h
index 6904b5e797..24e09b812e 100644
--- a/finch/libgnt/gntcolors.h
+++ b/finch/libgnt/gntcolors.h
@@ -34,7 +34,16 @@
  */
 typedef enum
 {
-	GNT_COLOR_NORMAL = 1,
+	GNT_COLOR_BLACK = 0,
+	GNT_COLOR_RED,
+	GNT_COLOR_GREEN,
+	GNT_COLOR_YELLOW,
+	GNT_COLOR_BLUE,
+	GNT_COLOR_MAGENTA,
+	GNT_COLOR_CYAN,
+	GNT_COLOR_WHITE,
+
+	GNT_COLOR_NORMAL,
 	GNT_COLOR_HIGHLIGHT,		/* eg. when a button is selected */
 	GNT_COLOR_DISABLED,		/* eg. when a button is disabled */
 	GNT_COLOR_HIGHLIGHT_D,	/* eg. when a button is selected, but some other window is in focus */
@@ -49,18 +58,6 @@ typedef enum
 	GNT_COLORS
 } GntColorType;
 
-enum
-{
-	GNT_COLOR_BLACK = 0,
-	GNT_COLOR_RED,
-	GNT_COLOR_GREEN,
-	GNT_COLOR_BLUE,
-	GNT_COLOR_WHITE,
-	GNT_COLOR_GRAY,
-	GNT_COLOR_DARK_GRAY,
-	GNT_TOTAL_COLORS
-};
-
 /**
  * Initialize the colors.
  */
@@ -122,4 +119,5 @@ int gnt_color_pair(int color);
  * @since 2.4.0
  */
 int gnt_color_add_pair(int fg, int bg);
+
 #endif
diff --git a/finch/libgnt/gnttextview.c b/finch/libgnt/gnttextview.c
index 31456805cc..eb3a3cb384 100644
--- a/finch/libgnt/gnttextview.c
+++ b/finch/libgnt/gnttextview.c
@@ -74,6 +74,13 @@ text_view_contains(GntTextView *view, const char *str)
 }
 
 static void
+gnt_text_view_draw_text(GntWidget *widget, GntTextFormatFlags fl, chtype at, char *s, char *e)
+{
+	wattrset(widget->window, at);
+	waddnstr(widget->window, s, e-s);
+}
+
+static void
 gnt_text_view_draw(GntWidget *widget)
 {
 	GntTextView *view = GNT_TEXT_VIEW(widget);
@@ -111,36 +118,26 @@ gnt_text_view_draw(GntWidget *widget)
 		for (iter = line->segments; iter; iter = iter->next)
 		{
 			GntTextSegment *seg = iter->data;
+			char *start = view->string->str + seg->start;
 			char *end = view->string->str + seg->end;
-			char back = *end;
-			chtype fl = seg->flags;
-			*end = '\0';
-			if (select_start && select_start < view->string->str + seg->start && select_end > view->string->str + seg->end) {
-				fl |= A_REVERSE;
-				wattrset(widget->window, fl);
-				wprintw(widget->window, "%s", C_(view->string->str + seg->start));
-			} else if (select_start && select_end &&
-				((select_start >= view->string->str + seg->start && select_start <= view->string->str + seg->end) ||
-				(select_end <= view->string->str + seg->end && select_start <= view->string->str + seg->start))) {
-				char *cur = view->string->str + seg->start;
-				while (*cur != '\0') {
-					gchar *last = g_utf8_next_char(cur);
-					gchar *str;
-					if (cur >= select_start && cur <= select_end)
-						fl |= A_REVERSE;
-					else
-						fl = seg->flags;
-					str = g_strndup(cur, last - cur);
-					wattrset(widget->window, fl);
-					waddstr(widget->window, C_(str));
-					g_free(str);
-					cur = g_utf8_next_char(cur);
-				}
-			} else {
-				wattrset(widget->window, fl);
-				wprintw(widget->window, "%s", C_(view->string->str + seg->start));
+			GntTextFormatFlags fl = seg->tvflag;
+			chtype at = seg->flags;
+			if (select_start && select_end && select_start < end && select_end >= start)
+			{
+				char *s = start;
+				char *e = select_start;
+				if (e > s)
+					gnt_text_view_draw_text(widget, fl, at, s, e);
+				s = MAX(select_start, start);
+				e = MIN(select_end+1, end);
+				gnt_text_view_draw_text(widget, fl, at | A_REVERSE, s, e);
+				s = select_end+1;
+				e = end;
+				if (e > s)
+					gnt_text_view_draw_text(widget, fl, at, s, e);
 			}
-			*end = back;
+			else
+				gnt_text_view_draw_text(widget, fl, at, start, end);
 		}
 		wattroff(widget->window, A_UNDERLINE | A_BLINK | A_REVERSE);
 		whline(widget->window, ' ', widget->priv.width - line->length - has_scroll);
@@ -660,10 +657,10 @@ chtype gnt_text_format_flag_to_chtype(GntTextFormatFlags flags)
 		fl |= A_UNDERLINE;
 	if (flags & GNT_TEXT_FLAG_BLINK)
 		fl |= A_BLINK;
-
 	if (flags & GNT_TEXT_FLAG_DIM)
-		fl |= (A_DIM | gnt_color_pair(GNT_COLOR_DISABLED));
-	else if (flags & GNT_TEXT_FLAG_HIGHLIGHT)
+		fl |= A_DIM;
+
+	if (flags & GNT_TEXT_FLAG_HIGHLIGHT)
 		fl |= (A_DIM | gnt_color_pair(GNT_COLOR_HIGHLIGHT));
 	else if ((flags & A_COLOR) == 0)
 		fl |= gnt_color_pair(GNT_COLOR_NORMAL);
diff --git a/finch/libgnt/gntutils.c b/finch/libgnt/gntutils.c
index 1e41c363c9..23bb1ac821 100644
--- a/finch/libgnt/gntutils.c
+++ b/finch/libgnt/gntutils.c
@@ -41,6 +41,7 @@
 #include <stdlib.h>
 #include <string.h>
 
+#include "libpurple/util.h"
 #ifndef NO_LIBXML
 #include <libxml/parser.h>
 #include <libxml/tree.h>
@@ -389,7 +390,11 @@ util_parse_html_to_tv(xmlNode *node, GntTextView *tv, GntTextFormatFlags flag)
 	gboolean insert_nl_s = FALSE, insert_nl_e = FALSE;
 
 	if (node == NULL || node->name == NULL || node->type != XML_ELEMENT_NODE)
+	{
+		if (node->type == XML_TEXT_NODE)
+			gnt_text_view_append_text_with_flags(tv, (char *)node->content, flag);
 		return;
+	}
 
 	name = (char*)node->name;
 	if (g_ascii_strcasecmp(name, "b") == 0 ||
@@ -416,6 +421,41 @@ util_parse_html_to_tv(xmlNode *node, GntTextView *tv, GntTextFormatFlags flag)
 		insert_nl_s = TRUE;
 		insert_nl_e = TRUE;
 		flag |= GNT_TEXT_FLAG_BOLD | GNT_TEXT_FLAG_UNDERLINE;
+	} else if (g_ascii_strcasecmp(name, "span") == 0) {
+		xmlChar *style = xmlGetProp(node, (xmlChar *)"style");
+		if (style)
+		{
+			gchar *color, *textdec, *weight;
+			color = purple_markup_get_css_property((char *)style, "color");
+			textdec = purple_markup_get_css_property((char *)style, "text-decoration");
+			weight = purple_markup_get_css_property((char *)style, "font-weight");
+
+			if (color)
+			{
+				/* should use gdk_color_parse or similar */
+				if (!g_ascii_strcasecmp(color, "red"))
+					flag |= gnt_color_pair(GNT_COLOR_RED);
+				else if (!g_ascii_strcasecmp(color, "green"))
+					flag |= gnt_color_pair(GNT_COLOR_GREEN);
+				else if (!g_ascii_strcasecmp(color, "yellow"))
+					flag |= gnt_color_pair(GNT_COLOR_YELLOW);
+				else if (!g_ascii_strcasecmp(color, "blue"))
+					flag |= gnt_color_pair(GNT_COLOR_BLUE);
+				else if (!g_ascii_strcasecmp(color, "magenta"))
+					flag |= gnt_color_pair(GNT_COLOR_MAGENTA);
+				else if (!g_ascii_strcasecmp(color, "cyan"))
+					flag |= gnt_color_pair(GNT_COLOR_CYAN);
+			}
+			if (weight && !g_ascii_strcasecmp(textdec, "bold"))
+				flag |= GNT_TEXT_FLAG_BOLD;
+			if (textdec && !g_ascii_strcasecmp(textdec, "underline"))
+				flag |= GNT_TEXT_FLAG_UNDERLINE;
+
+			g_free(weight);
+			g_free(textdec);
+			g_free(color);
+			xmlFree(style);
+		}
 	} else {
 		/* XXX: Process other possible tags */
 	}
@@ -424,7 +464,7 @@ util_parse_html_to_tv(xmlNode *node, GntTextView *tv, GntTextFormatFlags flag)
 		gnt_text_view_append_text_with_flags(tv, "\n", flag);
 
 	for (ch = node->children; ch; ch = ch->next) {
-		if (ch->type == XML_ELEMENT_NODE) {
+		if (ch->type == XML_ELEMENT_NODE /* || ch->type == XML_TEXT_NODE */) {
 			util_parse_html_to_tv(ch, tv, flag);
 		} else if (ch->type == XML_TEXT_NODE) {
 			content = (char*)xmlNodeGetContent(ch);
@@ -445,15 +485,14 @@ util_parse_html_to_tv(xmlNode *node, GntTextView *tv, GntTextFormatFlags flag)
 }
 #endif
 
-gboolean gnt_util_parse_xhtml_to_textview(const char *string, GntTextView *tv)
+gboolean gnt_util_parse_xhtml_to_textview(const char *string, GntTextView *tv, GntTextFormatFlags flag)
 {
 #ifdef NO_LIBXML
 	return FALSE;
 #else
 	xmlParserCtxtPtr ctxt;
-	xmlDocPtr doc;
+	xmlDocPtr doc = NULL;
 	xmlNodePtr node;
-	GntTextFormatFlags flag = GNT_TEXT_FLAG_NORMAL;
 	gboolean ret = FALSE;
 
 	ctxt = xmlNewParserCtxt();
@@ -464,6 +503,11 @@ gboolean gnt_util_parse_xhtml_to_textview(const char *string, GntTextView *tv)
 		xmlFreeDoc(doc);
 		ret = TRUE;
 	}
+	else
+	{
+		gnt_text_view_append_text_with_flags(tv, "(HTML parse error) ", flag | GNT_TEXT_FLAG_BOLD);
+		gnt_text_view_append_text_with_flags(tv, string, flag);
+	}
 	xmlFreeParserCtxt(ctxt);
 	return ret;
 #endif
diff --git a/finch/libgnt/gntutils.h b/finch/libgnt/gntutils.h
index 7517d7420c..6c532fe557 100644
--- a/finch/libgnt/gntutils.h
+++ b/finch/libgnt/gntutils.h
@@ -142,7 +142,7 @@ void gnt_util_parse_widgets(const char *string, int num, ...);
  *
  * @since 2.2.0
  */
-gboolean gnt_util_parse_xhtml_to_textview(const char *string, GntTextView *tv);
+gboolean gnt_util_parse_xhtml_to_textview(const char *string, GntTextView *tv, GntTextFormatFlags flag);
 
 /**
  * Make some keypress activate a button when some key is pressed with 'wid' in focus.
diff --git a/finch/libgnt/gntwidget.h b/finch/libgnt/gntwidget.h
index e25d58f711..9ed6b13c26 100644
--- a/finch/libgnt/gntwidget.h
+++ b/finch/libgnt/gntwidget.h
@@ -66,6 +66,7 @@ typedef enum _GntWidgetFlags
 	GNT_WIDGET_INVISIBLE      = 1 << 10,
 	GNT_WIDGET_TRANSIENT      = 1 << 11,
 	GNT_WIDGET_DISABLE_ACTIONS = 1 << 12,
+	GNT_WIDGET_SWITCH_SKIP	  = 1 << 13,
 } GntWidgetFlags;
 
 /* XXX: This will probably move elsewhere */
@@ -103,6 +104,7 @@ struct _GntWidget
 
 	GntWidgetPriv priv;
 	WINDOW *window;
+	struct _GntNode *wmnode;
 
     void (*gnt_reserved1)(void);
     void (*gnt_reserved2)(void);
diff --git a/finch/libgnt/gntwm.c b/finch/libgnt/gntwm.c
index 310d6c621c..21c18b439f 100644
--- a/finch/libgnt/gntwm.c
+++ b/finch/libgnt/gntwm.c
@@ -123,14 +123,20 @@ g_list_bring_to_front(GList *list, gpointer data)
 }
 
 static void
-free_node(gpointer data)
+free_node(GntNode *node)
 {
-	GntNode *node = data;
 	hide_panel(node->panel);
 	del_panel(node->panel);
 	g_free(node);
 }
 
+static GntNode *
+gnt_wm_widget_node(GntWM *wm, GntWidget *widget)
+{
+	/* return g_hash_table_lookup(wm->nodes, widget); */
+	return widget->wmnode;
+}
+
 void
 gnt_wm_copy_win(GntWidget *widget, GntNode *node)
 {
@@ -248,7 +254,7 @@ update_screen(GntWM *wm)
 	if (wm->menu) {
 		GntMenu *top = wm->menu;
 		while (top) {
-			GntNode *node = g_hash_table_lookup(wm->nodes, top);
+			GntNode *node = gnt_wm_widget_node(wm, GNT_WIDGET(top));
 			if (node)
 				top_panel(node->panel);
 			top = top->submenu;
@@ -300,8 +306,10 @@ sanitize_position(GntWidget *widget, int *x, int *y, gboolean m)
 }
 
 static void
-refresh_node(GntWidget *widget, GntNode *node, gpointer m)
+refresh_node(GntNode *node, gpointer m)
 {
+	GntWidget *widget = node->me;
+
 	int x, y, w, h;
 	int nw, nh;
 
@@ -409,7 +417,7 @@ gnt_wm_init(GTypeInstance *instance, gpointer class)
 	wm->tagged = NULL;
 	wm->windows = NULL;
 	wm->actions = NULL;
-	wm->nodes = g_hash_table_new_full(g_direct_hash, g_direct_equal, NULL, free_node);
+	wm->nodes = NULL;
 	wm->positions = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);
 	if (gnt_style_get_bool(GNT_STYLE_REMPOS, TRUE))
 		read_window_positions(wm);
@@ -448,7 +456,7 @@ switch_window(GntWM *wm, int direction, gboolean urgent)
 			pos = 0;
 		} else
 			wid = g_list_nth_data(wm->cws->list, pos);
-	} while (urgent && !GNT_WIDGET_IS_FLAG_SET(wid, GNT_WIDGET_URGENT) && pos != orgpos);
+	} while ((GNT_WIDGET_IS_FLAG_SET(wid, GNT_WIDGET_SWITCH_SKIP) || (urgent && !GNT_WIDGET_IS_FLAG_SET(wid, GNT_WIDGET_URGENT))) && pos != orgpos);
 
 	gnt_wm_raise_window(wm, wid);
 }
@@ -503,7 +511,7 @@ window_scroll_up(GntBindable *bindable, GList *null)
 		return TRUE;
 
 	window = wm->cws->ordered->data;
-	node = g_hash_table_lookup(wm->nodes, window);
+	node = gnt_wm_widget_node(wm, window);
 	if (!node)
 		return TRUE;
 
@@ -527,7 +535,7 @@ window_scroll_down(GntBindable *bindable, GList *null)
 		return TRUE;
 
 	window = wm->cws->ordered->data;
-	node = g_hash_table_lookup(wm->nodes, window);
+	node = gnt_wm_widget_node(wm, window);
 	if (!node)
 		return TRUE;
 
@@ -900,6 +908,7 @@ shift_window(GntWM *wm, GntWidget *widget, int dir)
 	all = g_list_delete_link(all, list);
 	wm->cws->list = all;
 	gnt_ws_draw_taskbar(wm->cws, FALSE);
+#ifdef BROKENWINCH
 	if (wm->cws->ordered) {
 		GntWidget *w = wm->cws->ordered->data;
 		GntNode *node = g_hash_table_lookup(wm->nodes, w);
@@ -907,6 +916,7 @@ shift_window(GntWM *wm, GntWidget *widget, int dir)
 		update_panels();
 		doupdate();
 	}
+#endif
 }
 
 static gboolean
@@ -1060,7 +1070,7 @@ window_reverse(GntWidget *win, gboolean set, GntWM *wm)
 	for (i = 0; i < h; i += reverse_char(d, i, 0, set));
 	for (i = 0; i < h; i += reverse_char(d, i, w-1, set));
 
-	gnt_wm_copy_win(win, g_hash_table_lookup(wm->nodes, win));
+	gnt_wm_copy_win(win, gnt_wm_widget_node(wm, win));
 	update_screen(wm);
 }
 
@@ -1129,14 +1139,16 @@ refresh_screen(GntBindable *bindable, GList *null)
 	endwin();
 	refresh();
 
-	g_hash_table_foreach(wm->nodes, (GHFunc)refresh_node, GINT_TO_POINTER(TRUE));
+	g_list_foreach(wm->nodes, (GFunc)refresh_node, GINT_TO_POINTER(TRUE));
 	g_signal_emit(wm, signals[SIG_TERMINAL_REFRESH], 0);
 
+#ifdef BROKENWINCH
 	for (iter = g_list_last(wm->cws->ordered); iter; iter = iter->prev) {
 		GntWidget *w = iter->data;
 		GntNode *node = g_hash_table_lookup(wm->nodes, w);
 		top_panel(node->panel);
 	}
+#endif
 
 	gnt_ws_draw_taskbar(wm->cws, TRUE);
 	update_screen(wm);
@@ -1373,11 +1385,9 @@ help_for_widget(GntBindable *bindable, GList *null)
 }
 
 static void
-accumulate_windows(gpointer window, gpointer node, gpointer p)
+accumulate_windows(GntNode *node, GList **list)
 {
-	GList *list = *(GList**)p;
-	list = g_list_prepend(list, window);
-	*(GList**)p = list;
+	*list = g_list_prepend(*list, node->me);
 }
 
 static void
@@ -1385,10 +1395,10 @@ gnt_wm_destroy(GObject *obj)
 {
 	GntWM *wm = GNT_WM(obj);
 	GList *list = NULL;
-	g_hash_table_foreach(wm->nodes, accumulate_windows, &list);
+	g_list_foreach(wm->nodes, (GFunc)accumulate_windows, &list);
 	g_list_foreach(list, (GFunc)gnt_widget_destroy, NULL);
 	g_list_free(list);
-	g_hash_table_destroy(wm->nodes);
+	g_list_free(wm->nodes);
 	wm->nodes = NULL;
 
 	while (wm->workspaces) {
@@ -1656,9 +1666,9 @@ gnt_wm_switch_workspace(GntWM *wm, gint n)
 		gnt_widget_destroy(wm->_list.window);
 	}
 	ensure_normal_mode(wm);
-	gnt_ws_hide(wm->cws, wm->nodes);
+	gnt_ws_hide(wm->cws);
 	wm->cws = s;
-	gnt_ws_show(wm->cws, wm->nodes);
+	gnt_ws_show(wm->cws);
 
 	gnt_ws_draw_taskbar(wm->cws, TRUE);
 	update_screen(wm);
@@ -1706,7 +1716,7 @@ gnt_wm_widget_move_workspace(GntWM *wm, GntWS *neww, GntWidget *widget)
 	GntNode *node;
 	if (!oldw || oldw == neww)
 		return;
-	node = g_hash_table_lookup(wm->nodes, widget);
+	node = gnt_wm_widget_node(wm, widget);
 	if (node && node->ws == neww)
 		return;
 
@@ -1716,9 +1726,9 @@ gnt_wm_widget_move_workspace(GntWM *wm, GntWS *neww, GntWidget *widget)
 	gnt_ws_remove_widget(oldw, widget);
 	gnt_ws_add_widget(neww, widget);
 	if (neww == wm->cws) {
-		gnt_ws_widget_show(widget, wm->nodes);
+		gnt_ws_widget_show(widget);
 	} else {
-		gnt_ws_widget_hide(widget, wm->nodes);
+		gnt_ws_widget_hide(widget);
 	}
 }
 
@@ -1830,9 +1840,15 @@ gnt_wm_new_window_real(GntWM *wm, GntWidget *widget)
 	node->me = widget;
 	node->scroll = 0;
 
-	g_hash_table_replace(wm->nodes, widget, node);
+	if (widget->wmnode)
+	{
+		wm->nodes = g_list_remove(wm->nodes, widget->wmnode);
+		free_node(widget->wmnode);
+	}
+	widget->wmnode = node;
+	wm->nodes = g_list_append(wm->nodes, node);
 
-	refresh_node(widget, node, GINT_TO_POINTER(TRUE));
+	refresh_node(node, GINT_TO_POINTER(TRUE));
 
 	transient = !!GNT_WIDGET_IS_FLAG_SET(node->me, GNT_WIDGET_TRANSIENT);
 
@@ -1889,7 +1905,7 @@ gnt_wm_new_window_real(GntWM *wm, GntWidget *widget)
 			gnt_widget_set_focus(node->me, FALSE);
 			gnt_widget_set_urgent(node->me);
 			if (wm->cws != ws)
-				gnt_ws_widget_hide(widget, wm->nodes);
+				gnt_ws_widget_hide(widget);
 		}
 	}
 }
@@ -1900,7 +1916,7 @@ void gnt_wm_new_window(GntWM *wm, GntWidget *widget)
 		widget = widget->parent;
 
 	if (GNT_WIDGET_IS_FLAG_SET(widget, GNT_WIDGET_INVISIBLE) ||
-			g_hash_table_lookup(wm->nodes, widget)) {
+			gnt_wm_widget_node(wm, widget)) {
 		update_screen(wm);
 		return;
 	}
@@ -1945,11 +1961,16 @@ void gnt_wm_window_close(GntWM *wm, GntWidget *widget)
 
 	s = gnt_wm_widget_find_workspace(wm, widget);
 
-	if (g_hash_table_lookup(wm->nodes, widget) == NULL)
+	if (gnt_wm_widget_node(wm, widget) == NULL)
 		return;
 
 	g_signal_emit(wm, signals[SIG_CLOSE_WIN], 0, widget);
-	g_hash_table_remove(wm->nodes, widget);
+	if (widget->wmnode)
+	{
+		wm->nodes = g_list_remove(wm->nodes, widget->wmnode);
+		free_node(widget->wmnode);
+		widget->wmnode = NULL;
+	}
 
 	if (wm->windows) {
 		gnt_tree_remove(GNT_TREE(wm->windows->tree), widget);
@@ -2100,13 +2121,13 @@ gboolean gnt_wm_process_input(GntWM *wm, const char *keys)
 static void
 gnt_wm_win_resized(GntWM *wm, GntNode *node)
 {
-	/*refresh_node(node->me, node, NULL);*/
+	/*refresh_node(node, NULL);*/
 }
 
 static void
 gnt_wm_win_moved(GntWM *wm, GntNode *node)
 {
-	refresh_node(node->me, node, NULL);
+	refresh_node(node, NULL);
 }
 
 void gnt_wm_resize_window(GntWM *wm, GntWidget *widget, int width, int height)
@@ -2117,7 +2138,7 @@ void gnt_wm_resize_window(GntWM *wm, GntWidget *widget, int width, int height)
 
 	while (widget->parent)
 		widget = widget->parent;
-	node = g_hash_table_lookup(wm->nodes, widget);
+	node = gnt_wm_widget_node(wm, widget);
 	if (!node)
 		return;
 
@@ -2188,7 +2209,7 @@ void gnt_wm_move_window(GntWM *wm, GntWidget *widget, int x, int y)
 
 	while (widget->parent)
 		widget = widget->parent;
-	node = g_hash_table_lookup(wm->nodes, widget);
+	node = gnt_wm_widget_node(wm, widget);
 	if (!node)
 		return;
 
@@ -2219,7 +2240,7 @@ void gnt_wm_move_window(GntWM *wm, GntWidget *widget, int x, int y)
 static void
 gnt_wm_give_focus(GntWM *wm, GntWidget *widget)
 {
-	GntNode *node = g_hash_table_lookup(wm->nodes, widget);
+	GntNode *node = gnt_wm_widget_node(wm, widget);
 
 	if (!node)
 		return;
@@ -2237,7 +2258,7 @@ gnt_wm_give_focus(GntWM *wm, GntWidget *widget)
 	top_panel(node->panel);
 
 	if (wm->_list.window) {
-		GntNode *nd = g_hash_table_lookup(wm->nodes, wm->_list.window);
+		GntNode *nd = gnt_wm_widget_node(wm, wm->_list.window);
 		top_panel(nd->panel);
 	}
 	gnt_ws_draw_taskbar(wm->cws, FALSE);
@@ -2258,7 +2279,7 @@ void gnt_wm_update_window(GntWM *wm, GntWidget *widget)
 	}
 
 	ws = gnt_wm_widget_find_workspace(wm, widget);
-	node = g_hash_table_lookup(wm->nodes, widget);
+	node = gnt_wm_widget_node(wm, widget);
 	if (node == NULL) {
 		gnt_wm_new_window(wm, widget);
 	} else
diff --git a/finch/libgnt/gntwm.h b/finch/libgnt/gntwm.h
index 4d8ace2428..97660582fe 100644
--- a/finch/libgnt/gntwm.h
+++ b/finch/libgnt/gntwm.h
@@ -93,7 +93,7 @@ struct _GntWM
 		*windows,         /* Window-list window */
 		*actions;         /* Action-list window */
 
-	GHashTable *nodes;    /* GntWidget -> GntNode */
+	GList *nodes;    /* GntNode */
 	GHashTable *name_places;    /* window name -> ws*/
 	GHashTable *title_places;    /* window title -> ws */
 
diff --git a/finch/libgnt/gntws.c b/finch/libgnt/gntws.c
index d8d35c1ed0..c081c5c68a 100644
--- a/finch/libgnt/gntws.c
+++ b/finch/libgnt/gntws.c
@@ -30,10 +30,10 @@
 #include "gntws.h"
 
 static void
-widget_hide(gpointer data, gpointer nodes)
+widget_hide(gpointer data, gpointer unused)
 {
 	GntWidget *widget = GNT_WIDGET(data);
-	GntNode *node = g_hash_table_lookup(nodes, widget);
+	GntNode *node = widget->wmnode;
 	if (GNT_IS_WINDOW(widget))
 		gnt_window_workspace_hiding(GNT_WINDOW(widget));
 	if (node)
@@ -41,13 +41,14 @@ widget_hide(gpointer data, gpointer nodes)
 }
 
 static void
-widget_show(gpointer data, gpointer nodes)
+widget_show(gpointer data)
 {
-	GntNode *node = g_hash_table_lookup(nodes, data);
-	GNT_WIDGET_UNSET_FLAGS(GNT_WIDGET(data), GNT_WIDGET_INVISIBLE);
+	GntWidget *widget = GNT_WIDGET(data);
+	GntNode *node = widget->wmnode;
+	GNT_WIDGET_UNSET_FLAGS(widget, GNT_WIDGET_INVISIBLE);
 	if (node) {
 		show_panel(node->panel);
-		gnt_wm_copy_win(GNT_WIDGET(data), node);
+		gnt_wm_copy_win(widget, node);
 	}
 }
 
@@ -74,15 +75,22 @@ gnt_ws_draw_taskbar(GntWS *ws, gboolean reposition)
 	wbkgdset(taskbar, '\0' | gnt_color_pair(GNT_COLOR_NORMAL));
 	werase(taskbar);
 
-	n = g_list_length(ws->list);
+	for (n = 0, iter = ws->list; iter; iter = iter->next) {
+		if (GNT_WIDGET_IS_FLAG_SET(iter->data, GNT_WIDGET_SWITCH_SKIP))
+			continue;
+		n++;
+	}
 	if (n)
 		width = getmaxx(stdscr) / n;
 
-	for (i = 0, iter = ws->list; iter; iter = iter->next, i++) {
+	for (i = 0, iter = ws->list; iter; iter = iter->next) {
 		GntWidget *w = iter->data;
 		int color;
 		const char *title;
 
+		if (GNT_WIDGET_IS_FLAG_SET(w, GNT_WIDGET_SWITCH_SKIP))
+			continue;
+
 		if (w == ws->ordered->data) {
 			/* This is the current window in focus */
 			color = GNT_COLOR_TITLE;
@@ -101,6 +109,7 @@ gnt_ws_draw_taskbar(GntWS *ws, gboolean reposition)
 		mvwprintw(taskbar, 0, width * i, "%s", title ? C_(title) : "<gnt>");
 		if (i)
 			mvwaddch(taskbar, 0, width *i - 1, ACS_VLINE | A_STANDOUT | gnt_color_pair(GNT_COLOR_NORMAL));
+		i++;
 	}
 	wrefresh(taskbar);
 }
@@ -138,27 +147,27 @@ gnt_ws_set_name(GntWS *ws, const gchar *name)
 }
 
 void
-gnt_ws_hide(GntWS *ws, GHashTable *nodes)
+gnt_ws_hide(GntWS *ws)
 {
-	g_list_foreach(ws->ordered, widget_hide, nodes);
+	g_list_foreach(ws->ordered, (GFunc)widget_hide, NULL);
 }
 
-void gnt_ws_widget_hide(GntWidget *widget, GHashTable *nodes)
+void gnt_ws_widget_hide(GntWidget *widget)
 {
-	widget_hide(widget, nodes);
+	widget_hide(widget, NULL);
 }
 
-void gnt_ws_widget_show(GntWidget *widget, GHashTable *nodes)
+void gnt_ws_widget_show(GntWidget *widget)
 {
-	widget_show(widget, nodes);
+	widget_show(widget);
 }
 
 void
-gnt_ws_show(GntWS *ws, GHashTable *nodes)
+gnt_ws_show(GntWS *ws)
 {
 	GList *l;
 	for (l = g_list_last(ws->ordered); l; l = g_list_previous(l))
-		widget_show(l->data, nodes);
+		widget_show(l->data);
 }
 
 GType
diff --git a/finch/libgnt/gntws.h b/finch/libgnt/gntws.h
index 795921b196..bf76e09696 100644
--- a/finch/libgnt/gntws.h
+++ b/finch/libgnt/gntws.h
@@ -121,21 +121,19 @@ void gnt_ws_remove_widget(GntWS *ws, GntWidget *widget);
  * Hide a widget in a workspace.
  *
  * @param widget  The widget to hide.
- * @param nodes   A hashtable containing information about the widgets.
  *
  * @since 2.0.0 (gnt), 2.1.0 (pidgin)
  */
-void gnt_ws_widget_hide(GntWidget *widget, GHashTable *nodes);
+void gnt_ws_widget_hide(GntWidget *widget);
 
 /**
  * Show a widget in a workspace.
  *
  * @param widget   The widget to show.
- * @param nodes   A hashtable containing information about the widgets.
  *
  * @since 2.0.0 (gnt), 2.1.0 (pidgin)
  */
-void gnt_ws_widget_show(GntWidget *widget, GHashTable *nodes);
+void gnt_ws_widget_show(GntWidget *widget);
 
 /**
  * Draw the taskbar in a workspace.
@@ -155,7 +153,7 @@ void gnt_ws_draw_taskbar(GntWS *ws, gboolean reposition);
  *
  * @since 2.0.0 (gnt), 2.1.0 (pidgin)
  */
-void gnt_ws_hide(GntWS *ws, GHashTable *table);
+void gnt_ws_hide(GntWS *ws);
 
 /**
  * Show a workspace.
@@ -165,7 +163,7 @@ void gnt_ws_hide(GntWS *ws, GHashTable *table);
  *
  * @since 2.0.0 (gnt), 2.1.0 (pidgin)
  */
-void gnt_ws_show(GntWS *ws, GHashTable *table);
+void gnt_ws_show(GntWS *ws);
 
 /**
  * Get the name of a workspace.
diff --git a/finch/libgnt/wms/Makefile.am b/finch/libgnt/wms/Makefile.am
index b72069a3d8..61b37c4944 100644
--- a/finch/libgnt/wms/Makefile.am
+++ b/finch/libgnt/wms/Makefile.am
@@ -1,13 +1,14 @@
 wms = irssi.la
 if PURPLE_AVAILABLE
 # These custom wms depend on libpurple
-purple_wms = s.la
+purple_wms = s.la full.la
 else
 purple_wms =
 endif
 
 s_la_LDFLAGS             = -module -avoid-version
 irssi_la_LDFLAGS         = -module -avoid-version
+full_la_LDFLAGS          = -module -avoid-version
 
 plugin_LTLIBRARIES = \
 	$(wms) \
@@ -20,6 +21,11 @@ irssi_la_LIBADD =  \
   $(GLIB_LIBS) \
   ../libgnt.la
 
+full_la_SOURCES = full.c
+full_la_LIBADD =  \
+  $(GLIB_LIBS) \
+  $(top_builddir)/finch/libgnt/libgnt.la
+
 s_la_SOURCES = s.c
 s_la_LIBADD =  \
   $(GLIB_LIBS) \
diff --git a/finch/libgnt/wms/full.c b/finch/libgnt/wms/full.c
new file mode 100644
index 0000000000..0d7ee7dead
--- /dev/null
+++ b/finch/libgnt/wms/full.c
@@ -0,0 +1,196 @@
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+
+#include "debug.h"
+#include "gnt.h"
+#include "gntbox.h"
+#include "gntmenu.h"
+#include "gntstyle.h"
+#include "gntwm.h"
+#include "gntwindow.h"
+#include "gntlabel.h"
+
+#include "blist.h"
+
+#define TYPE_FULL				(full_get_gtype())
+
+typedef struct _Full
+{
+	GntWM inherit;
+
+	gboolean borders;
+	int blistwidth;
+} Full;
+
+typedef struct _FullClass
+{
+	GntWMClass inherit;
+} FullClass;
+
+GType full_get_gtype(void);
+void gntwm_init(GntWM **wm);
+
+static void (*org_new_window)(GntWM *wm, GntWidget *win);
+
+static void
+draw_line_separators(Full *full)
+{
+	/*
+	wclear(stdscr);
+	if (full->blistwidth >= 0)
+		mvwvline(stdscr, 0, getmaxx(stdscr) - full->blistwidth - 1,
+				ACS_VLINE | COLOR_PAIR(GNT_COLOR_NORMAL), getmaxy(stdscr) - 1);
+	*/
+}
+
+static gboolean
+is_blist(GntWidget *win)
+{
+	const char *name = gnt_widget_get_name(win);
+	if (name && strcmp(name, "buddylist") == 0)
+		return TRUE;
+	return FALSE;
+}
+
+static void
+relocate_win(Full *full, GntWidget *win, int x, int y, int w, int h)
+{
+	GntNode *node = win->wmnode; // g_hash_table_lookup(GNT_WM(full)->nodes, win);
+	// purple_debug(PURPLE_DEBUG_INFO, "full", "relocate %s %p %p %d,%d,%d,%d\n", gnt_widget_get_name(win), win, win->parent, x,y,w,h);
+	if (!full->borders && !GNT_WIDGET_IS_FLAG_SET(win, GNT_WIDGET_NO_BORDER))
+	{
+		GNT_WIDGET_SET_FLAGS(win, GNT_WIDGET_NO_BORDER | GNT_WIDGET_NO_SHADOW);
+		w += 2; h += 2;
+	}
+	if (node)
+	{
+		hide_panel(node->panel);
+	}
+	gnt_widget_set_size(win, w, h);
+	gnt_widget_set_position(win, x, y);
+	if (node)
+	{
+		wresize(node->window, h, w);
+		replace_panel(node->panel, node->window);
+		show_panel(node->panel);
+		move_panel(node->panel, y, x);
+	}
+}
+
+static void
+place_win(Full *full, GntWidget *win)
+{
+	if (is_blist(win))
+	{
+		if (full->blistwidth <= 0)
+			gnt_widget_get_size(win, &full->blistwidth, NULL);
+		relocate_win(full, win, getmaxx(stdscr)-full->blistwidth-full->borders, 0, full->blistwidth+full->borders, getmaxy(stdscr)-1);
+	}
+	else if (!GNT_IS_MENU(win) && !GNT_WIDGET_IS_FLAG_SET(win, GNT_WIDGET_TRANSIENT)) {
+		relocate_win(full, win, 0, 0, getmaxx(stdscr) - full->blistwidth, getmaxy(stdscr)-1);
+	}
+}
+
+static void
+full_new_window(GntWM *wm, GntWidget *win)
+{
+	Full *full = (Full *)wm;
+	if (is_blist(win))
+		GNT_WIDGET_SET_FLAGS(win, GNT_WIDGET_SWITCH_SKIP);
+	place_win(full, win);
+	org_new_window(wm, win);
+}
+
+static void
+full_terminal_refresh(GntWM *wm)
+{
+	Full *full = (Full *)wm;
+	GList *iter;
+	for (iter = wm->cws->list; iter; iter = iter->next) {
+		GntWidget *win = GNT_WIDGET(iter->data);
+		place_win(full, win);
+	}
+
+	draw_line_separators(full);
+	// update_panels();
+	// doupdate();
+}
+
+static gboolean
+focus_blist(GntBindable *bindable, GList *null)
+{
+	purple_blist_show();
+	return TRUE;
+}
+
+static gboolean
+full_only_transients(GntWM *wm, GntWidget *win, int *a, int *b)
+{
+	// purple_debug(PURPLE_DEBUG_INFO, "full", "confirm %s %p %p %d,%d\n", gnt_widget_get_name(w), w, w->parent, *a,*b);
+	return GNT_IS_MENU(win) || GNT_WIDGET_IS_FLAG_SET(win, GNT_WIDGET_TRANSIENT);
+}
+
+static void
+full_class_init(FullClass *klass)
+{
+	GntWMClass *pclass = GNT_WM_CLASS(klass);
+
+	org_new_window = pclass->new_window;
+
+	pclass->new_window = full_new_window;
+	//pclass->window_resized = full_window_resized;
+	//pclass->close_window = full_close_window;
+	pclass->window_resize_confirm = full_only_transients;
+	pclass->window_move_confirm = full_only_transients;
+	pclass->terminal_refresh = full_terminal_refresh;
+
+	gnt_bindable_class_register_action(GNT_BINDABLE_CLASS(klass), "window-blist", focus_blist, "\033" "b", NULL);
+
+	gnt_style_read_actions(G_OBJECT_CLASS_TYPE(klass), GNT_BINDABLE_CLASS(klass));
+	GNTDEBUG;
+}
+
+void gntwm_init(GntWM **wm)
+{
+	char *style = NULL;
+	Full *full;
+
+	full = g_object_new(TYPE_FULL, NULL);
+	*wm = GNT_WM(full);
+
+	style = gnt_style_get_from_name("full", "blist-width");
+	full->blistwidth = style ? atoi(style) : 0;
+	g_free(style);
+
+	style = gnt_style_get_from_name("full", "borders");
+	full->borders = gnt_style_parse_bool(style);
+	g_free(style);
+}
+
+GType full_get_gtype(void)
+{
+	static GType type = 0;
+
+	if(type == 0) {
+		static const GTypeInfo info = {
+			sizeof(FullClass),
+			NULL,           /* base_init		*/
+			NULL,           /* base_finalize	*/
+			(GClassInitFunc)full_class_init,
+			NULL,
+			NULL,           /* class_data		*/
+			sizeof(Full),
+			0,              /* n_preallocs		*/
+			NULL,	        /* instance_init	*/
+			NULL
+		};
+
+		type = g_type_register_static(GNT_TYPE_WM,
+		                              "GntFull",
+		                              &info, 0);
+	}
+
+	return type;
+}
+
diff --git a/libpurple/conversation.c b/libpurple/conversation.c
index 8a39b600d4..b1c56eee59 100644
--- a/libpurple/conversation.c
+++ b/libpurple/conversation.c
@@ -335,6 +335,8 @@ purple_conversation_new(PurpleConversationType type, PurpleAccount *account,
 	PurpleConnection *gc;
 	PurpleConversationUiOps *ops;
 	struct _purple_hconv *hc;
+	gboolean log = FALSE;
+	PurpleBlistNode *node = NULL;
 
 	g_return_val_if_fail(type    != PURPLE_CONV_TYPE_UNKNOWN, NULL);
 	g_return_val_if_fail(account != NULL, NULL);
@@ -386,6 +388,8 @@ purple_conversation_new(PurpleConversationType type, PurpleAccount *account,
 	if (type == PURPLE_CONV_TYPE_IM)
 	{
 		PurpleBuddyIcon *icon;
+		PurpleBuddy *b;
+
 		conv->u.im = g_new0(PurpleConvIm, 1);
 		conv->u.im->conv = conv;
 		PURPLE_DBUS_REGISTER_POINTER(conv->u.im, PurpleConvIm);
@@ -398,15 +402,14 @@ purple_conversation_new(PurpleConversationType type, PurpleAccount *account,
 			purple_buddy_icon_unref(icon);
 		}
 
-		if (purple_prefs_get_bool("/purple/logging/log_ims"))
-		{
-			purple_conversation_set_logging(conv, TRUE);
-			open_log(conv);
-		}
+		log = purple_prefs_get_bool("/purple/logging/log_ims");
+		if ((b = purple_find_buddy(account, name)))
+			node = &b->node;
 	}
 	else if (type == PURPLE_CONV_TYPE_CHAT)
 	{
 		const char *disp;
+		PurpleChat *c;
 
 		conv->u.chat = g_new0(PurpleConvChat, 1);
 		conv->u.chat->conv = conv;
@@ -422,11 +425,18 @@ purple_conversation_new(PurpleConversationType type, PurpleAccount *account,
 			purple_conv_chat_set_nick(conv->u.chat,
 									purple_account_get_username(account));
 
-		if (purple_prefs_get_bool("/purple/logging/log_chats"))
-		{
-			purple_conversation_set_logging(conv, TRUE);
-			open_log(conv);
-		}
+		log = purple_prefs_get_bool("/purple/logging/log_chats");
+		if ((c = purple_blist_find_chat(account, name)))
+			node = &c->node;
+	}
+
+	if (!log && node)
+		log = purple_blist_node_get_bool(node, "log");
+
+	if (log)
+	{
+		purple_conversation_set_logging(conv, TRUE);
+		open_log(conv);
 	}
 
 	conversations = g_list_prepend(conversations, conv);
@@ -907,6 +917,7 @@ purple_find_conversation_with_account(PurpleConversationType type,
 	switch (type) {
 		case PURPLE_CONV_TYPE_IM:
 		case PURPLE_CONV_TYPE_CHAT:
+		case PURPLE_CONV_TYPE_MISC:
 			c = g_hash_table_lookup(conversation_cache, &hc);
 			break;
 		case PURPLE_CONV_TYPE_ANY:
diff --git a/libpurple/log.c b/libpurple/log.c
index ea583fce48..a080ff8581 100644
--- a/libpurple/log.c
+++ b/libpurple/log.c
@@ -51,6 +51,7 @@ static GHashTable *logsize_users_decayed = NULL;
 
 static void log_get_log_sets_common(GHashTable *sets);
 
+static void html_logger_create(PurpleLog *log);
 static gsize html_logger_write(PurpleLog *log, PurpleMessageFlags type,
 							  const char *from, time_t time, const char *message);
 static void html_logger_finalize(PurpleLog *log);
@@ -66,6 +67,7 @@ static int old_logger_size (PurpleLog *log);
 static void old_logger_get_log_sets(PurpleLogSetCallback cb, GHashTable *sets);
 static void old_logger_finalize(PurpleLog *log);
 
+static void txt_logger_create(PurpleLog *log);
 static gsize txt_logger_write(PurpleLog *log,
 							 PurpleMessageFlags type,
 							 const char *from, time_t time, const char *message);
@@ -653,7 +655,7 @@ void purple_log_init(void)
 	purple_prefs_add_string("/purple/logging/format", "html");
 
 	html_logger = purple_log_logger_new("html", _("HTML"), 11,
-									  NULL,
+									  html_logger_create,
 									  html_logger_write,
 									  html_logger_finalize,
 									  html_logger_list,
@@ -667,7 +669,7 @@ void purple_log_init(void)
 	purple_log_logger_add(html_logger);
 
 	txt_logger = purple_log_logger_new("txt", _("Plain text"), 11,
-									 NULL,
+									 txt_logger_create,
 									 txt_logger_write,
 									 txt_logger_finalize,
 									 txt_logger_list,
@@ -755,7 +757,7 @@ static char *log_get_timestamp(PurpleLog *log, time_t when)
 	char *date;
 	struct tm *tm;
 
-	show_date = (log->type == PURPLE_LOG_SYSTEM) || (time(NULL) > when + 20*60);
+	show_date = TRUE;
 
 	date = purple_signal_emit_return_1(purple_log_get_handle(),
 	                          "log-timestamp",
@@ -1369,14 +1371,9 @@ static PurpleLogLogger xml_logger =  {
  ** HTML LOGGER *************
  ****************************/
 
-static gsize html_logger_write(PurpleLog *log, PurpleMessageFlags type,
-							  const char *from, time_t time, const char *message)
+static void html_logger_create(PurpleLog *log)
 {
-	char *msg_fixed;
-	char *image_corrected_msg;
-	char *date;
 	char *header;
-	char *escaped_from;
 	PurplePlugin *plugin = purple_find_prpl(purple_account_get_protocol_id(log->account));
 	PurpleLogCommonLoggerData *data = log->logger_data;
 	gsize written = 0;
@@ -1391,7 +1388,7 @@ static gsize html_logger_write(PurpleLog *log, PurpleMessageFlags type,
 
 		/* if we can't write to the file, give up before we hurt ourselves */
 		if(!data->file)
-			return 0;
+			return;
 
 		date = purple_date_format_full(localtime(&log->time));
 
@@ -1410,6 +1407,22 @@ static gsize html_logger_write(PurpleLog *log, PurpleMessageFlags type,
 		written += fprintf(data->file, "<h3>%s</h3>\n", header);
 		g_free(header);
 	}
+}
+
+static gsize html_logger_write(PurpleLog *log, PurpleMessageFlags type,
+							  const char *from, time_t time, const char *message)
+{
+	char *msg_fixed;
+	char *image_corrected_msg;
+	char *date;
+	char *escaped_from;
+	PurpleLogCommonLoggerData *data = log->logger_data;
+	gsize written = 0;
+
+	if(!data) {
+		html_logger_create(log);
+		data = log->logger_data;
+	}
 
 	/* if we can't write to the file, give up before we hurt ourselves */
 	if(!data->file)
@@ -1527,15 +1540,10 @@ static int html_logger_total_size(PurpleLogType type, const char *name, PurpleAc
  ** PLAIN TEXT LOGGER *******
  ****************************/
 
-static gsize txt_logger_write(PurpleLog *log,
-							 PurpleMessageFlags type,
-							 const char *from, time_t time, const char *message)
+static void txt_logger_create(PurpleLog *log)
 {
-	char *date;
 	PurplePlugin *plugin = purple_find_prpl(purple_account_get_protocol_id(log->account));
 	PurpleLogCommonLoggerData *data = log->logger_data;
-	char *stripped = NULL;
-
 	gsize written = 0;
 
 	if (data == NULL) {
@@ -1551,7 +1559,7 @@ static gsize txt_logger_write(PurpleLog *log,
 
 		/* if we can't write to the file, give up before we hurt ourselves */
 		if(!data->file)
-			return 0;
+			return;
 
 		if (log->type == PURPLE_LOG_SYSTEM)
 			written += fprintf(data->file, "System log for account %s (%s) connected at %s\n",
@@ -1562,6 +1570,22 @@ static gsize txt_logger_write(PurpleLog *log,
 				log->name, purple_date_format_full(localtime(&log->time)),
 				purple_account_get_username(log->account), prpl);
 	}
+}
+
+static gsize txt_logger_write(PurpleLog *log,
+							 PurpleMessageFlags type,
+							 const char *from, time_t time, const char *message)
+{
+	char *date;
+	PurpleLogCommonLoggerData *data = log->logger_data;
+	char *stripped = NULL;
+
+	gsize written = 0;
+
+	if (data == NULL) {
+		txt_logger_create(log);
+		data = log->logger_data;
+	}
 
 	/* if we can't write to the file, give up before we hurt ourselves */
 	if(!data->file)
diff --git a/libpurple/media/backend-fs2.h b/libpurple/media/backend-fs2.h
index 47fb02dac5..e6d54e4237 100644
--- a/libpurple/media/backend-fs2.h
+++ b/libpurple/media/backend-fs2.h
@@ -60,6 +60,7 @@ GType purple_media_backend_fs2_get_type(void);
  * Temporary function in order to be able to test while
  * integrating with PurpleMedia
  */
+#ifdef USE_GSTREAMER
 #include <gst/gst.h>
 GstElement *purple_media_backend_fs2_get_src(
 		PurpleMediaBackendFs2 *self,
@@ -71,6 +72,7 @@ void purple_media_backend_fs2_set_input_volume(PurpleMediaBackendFs2 *self,
 		const gchar *sess_id, double level);
 void purple_media_backend_fs2_set_output_volume(PurpleMediaBackendFs2 *self,
 		const gchar *sess_id, const gchar *who, double level);
+#endif
 /* end tmp */
 #endif /* USE_GSTREAMER */
 
diff --git a/libpurple/plugins/Makefile.am b/libpurple/plugins/Makefile.am
index adc6209773..053a6c6680 100644
--- a/libpurple/plugins/Makefile.am
+++ b/libpurple/plugins/Makefile.am
@@ -42,6 +42,9 @@ psychic_la_LDFLAGS          = -module -avoid-version
 signals_test_la_LDFLAGS		= -module -avoid-version
 simple_la_LDFLAGS			= -module -avoid-version
 statenotify_la_LDFLAGS      = -module -avoid-version
+statelog_la_LDFLAGS      = -module -avoid-version
+syncnotify_la_LDFLAGS      = -module -avoid-version
+alertcount_la_LDFLAGS      = -module -avoid-version
 
 # this can't be in a conditional otherwise automake 1.4 yells
 dbus_example_la_LDFLAGS     = -module -avoid-version
@@ -58,6 +61,9 @@ plugin_LTLIBRARIES = \
 	offlinemsg.la       \
 	psychic.la          \
 	statenotify.la      \
+	statelog.la      \
+	syncnotify.la      \
+	alertcount.la      \
 	$(DBUS_LTLIB)
 
 noinst_LTLIBRARIES = \
@@ -89,6 +95,9 @@ psychic_la_SOURCES          = psychic.c
 signals_test_la_SOURCES		= signals-test.c
 simple_la_SOURCES			= simple.c
 statenotify_la_SOURCES      = statenotify.c
+statelog_la_SOURCES      = statelog.c
+syncnotify_la_SOURCES      = syncnotify.c
+alertcount_la_SOURCES      = alertcount.c
 
 autoaccept_la_LIBADD        = $(GLIB_LIBS)
 buddynote_la_LIBADD         = $(GLIB_LIBS)
@@ -106,6 +115,9 @@ psychic_la_LIBADD           = $(GLIB_LIBS)
 signals_test_la_LIBADD		= $(GLIB_LIBS)
 simple_la_LIBADD			= $(GLIB_LIBS)
 statenotify_la_LIBADD       = $(GLIB_LIBS)
+statelog_la_LIBADD       = $(GLIB_LIBS)
+syncnotify_la_LIBADD       = $(GLIB_LIBS)
+alertcount_la_LIBADD       = $(GLIB_LIBS)
 
 if ENABLE_DBUS
 
diff --git a/libpurple/plugins/alertcount.c b/libpurple/plugins/alertcount.c
new file mode 100644
index 0000000000..e9901bda27
--- /dev/null
+++ b/libpurple/plugins/alertcount.c
@@ -0,0 +1,322 @@
+#define _GNU_SOURCE
+#include "internal.h"
+#include "debug.h"
+#include "plugin.h"
+#include "version.h"
+
+/** Plugin id : type-author-name (to guarantee uniqueness) */
+#define ALERTS_PLUGIN_ID "core-dylex-alertcount"
+
+static int Listener = -1;
+static guint Incoming = 0;
+static int Connection = -1;
+static guint Outgoing = 0;
+static int Count = -1;
+
+#ifdef ACTIVITY
+static struct activity {
+	struct activity *next;
+	PurpleConversation *conv;
+	uint16_t count;
+	uint8_t ident;
+} *Activity = NULL;
+#endif
+
+static gboolean
+conversation_ignore(PurpleConversation *conv)
+{
+	return !strcmp(conv->name, "slackbot")
+		|| !strcmp(conv->name, "NickServ");
+}
+
+static uint8_t
+conversation_ident(PurpleConversation *conv)
+{
+	unsigned h;
+	/* hack to get rid of variables resource markers (jabber only?) */
+	char *p = strchrnul(strchrnul(conv->name, '@'), '/');
+	char o = *p;
+	*p = '\0';
+	h = g_str_hash(conv->name);
+	*p = o;
+	while (!(h & 0x7F) && h)
+		h >>= 7;
+	if (!h)
+		h = 0x7F;
+	return (conv->type << 7) | (h & 0x7F);
+}
+
+#ifdef ACTIVITY
+static void
+activity_update(PurpleConversation *conv, int count)
+{
+	struct activity **p, *a;
+	for (p = &Activity; *p && (*p)->conv != conv; p = &(*p)->next);
+	if ((a = *p)) {
+		if (count)
+			a->count = count;
+		else {
+			*p = a->next;
+			g_slice_free(struct activity, a);
+		}
+	} else if (count) {
+		a = *p = g_slice_new(struct activity);
+		a->next = NULL;
+		a->conv = conv;
+		a->count = count;
+		a->ident = conversation_ident(conv);
+	}
+}
+#endif
+
+static unsigned
+alerts_get_count(uint8_t *buf, size_t buflen)
+{
+	const gboolean aggregate = purple_prefs_get_bool("/plugins/core/alertcount/aggregate");
+	unsigned count = 0;
+	GList *l;
+	if (!aggregate)
+		buflen &= ~1;
+
+	for (l = purple_get_conversations(); l != NULL; l = l->next) {
+		PurpleConversation *conv = (PurpleConversation *)l->data;
+		if (conversation_ignore(conv))
+			continue;
+		int c = GPOINTER_TO_INT(purple_conversation_get_data(conv, "unseen-count"));
+		if (!c)
+			continue;
+		if (count < buflen) {
+			buf[count++] = conversation_ident(conv);
+			if (!aggregate)
+				buf[count++] = c;
+		} else if (aggregate)
+			count ++;
+		else
+			count += c;
+	}
+	Count = count;
+	return count;
+}
+
+static void
+alerts_outgoing_cb(gpointer data, gint source, PurpleInputCondition cond)
+{
+	const gboolean ident = purple_prefs_get_bool("/plugins/core/alertcount/ident");
+	unsigned c;
+	uint8_t buf[128];
+
+	if (Outgoing) {
+		purple_input_remove(Outgoing);
+		Outgoing = 0;
+	}
+
+	c = alerts_get_count(buf, ident ? 127 : 0);
+	if (c > 127)
+		c = 127;
+	if (ident)
+		buf[c++] = 0;
+	else {
+		*buf = c;
+		c = 1;
+	}
+	if (send(Connection, buf, c, 0) <= 0) { /* ignore short reads */
+		purple_debug_info("alertcount", "send: %m\n");
+		close(Connection);
+		Connection = -1;
+	}
+}
+
+static void
+alerts_incoming_cb(gpointer data, gint source, PurpleInputCondition cond)
+{
+	struct sockaddr_in addr;
+	socklen_t addrlen = sizeof(addr);
+
+	if (Outgoing) {
+		purple_input_remove(Outgoing);
+		Outgoing = 0;
+	}
+	if (Connection >= 0)
+		close(Connection);
+	if ((Connection = accept(Listener, (struct sockaddr *)&addr, &addrlen)) < 0)
+	{
+		purple_debug_warning("alertcount", "accept: %m\n");
+		return;
+	}
+
+	purple_debug_info("alertcount", "accepted connection from %s:%hu\n", inet_ntoa(addr.sin_addr), ntohs(addr.sin_port));
+	shutdown(Connection, SHUT_RD);
+	fcntl(Connection, F_SETFL, O_NONBLOCK);
+	fcntl(Connection, F_SETFD, FD_CLOEXEC);
+
+	Outgoing = purple_input_add(Connection, PURPLE_INPUT_WRITE, alerts_outgoing_cb, NULL);
+}
+
+static void
+alerts_conversation_cb(PurpleConversation *conv, PurpleConvUpdateType type, void *data)
+{
+	int c;
+
+	if (!(type & PURPLE_CONV_UPDATE_UNSEEN))
+		return;
+	if (Connection < 0 || Outgoing)
+		return;
+	if (conversation_ignore(conv))
+		return;
+	c = GPOINTER_TO_INT(purple_conversation_get_data(conv, "unseen-count"));
+	if (!Count && !c)
+		return;
+#ifdef ACTIVITY
+	activity_update(conv, c);
+#endif
+	Outgoing = purple_input_add(Connection, PURPLE_INPUT_WRITE, alerts_outgoing_cb, NULL);
+}
+
+static gboolean
+plugin_load(PurplePlugin *plugin)
+{
+	const int on = 1;
+	const struct sockaddr_in addr = {
+		.sin_family = AF_INET,
+		.sin_port = htons(purple_prefs_get_int("/plugins/core/alertcount/port")),
+		.sin_addr = { htonl(INADDR_LOOPBACK) }
+	};
+
+	if ((Listener = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
+		purple_debug_error("alertcount", "socket: %m\n");
+		goto error;
+	}
+	if (setsockopt(Listener, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on)) < 0)
+		purple_debug_warning("alertcount", "setsockopt(SO_REUSEADDR): %m\n");
+	if (bind(Listener, (struct sockaddr *)&addr, sizeof(addr)) < 0)
+	{
+		purple_debug_error("alertcount", "bind: %m\n");
+		goto error;
+	}
+	if (listen(Listener, 1) < 0) {
+		purple_debug_error("alertcount", "listen: %m\n");
+		goto error;
+	}
+
+	fcntl(Listener, F_SETFL, O_NONBLOCK);
+	fcntl(Listener, F_SETFD, FD_CLOEXEC);
+
+	Incoming = purple_input_add(Listener, PURPLE_INPUT_READ, alerts_incoming_cb, NULL);
+
+	purple_signal_connect(purple_conversations_get_handle(), "conversation-updated",
+			plugin, PURPLE_CALLBACK(alerts_conversation_cb), NULL);
+
+	return TRUE;
+
+error:
+	if (Listener >= 0) {
+		close(Listener);
+		Listener = -1;
+	}
+	return FALSE;
+}
+
+static gboolean
+plugin_unload(PurplePlugin *plugin)
+{
+#ifdef ACTIVITY
+	if (Activity) {
+		g_slice_free_chain(struct activity, Activity, next);
+		Activity = NULL;
+	}
+#endif
+	if (Outgoing) {
+		purple_input_remove(Outgoing);
+		Outgoing = 0;
+	}
+	if (Incoming) {
+		purple_input_remove(Incoming);
+		Incoming = 0;
+	}
+	if (Connection >= 0) {
+		close(Connection);
+		Connection = -1;
+	}
+	if (Listener >= 0) {
+		close(Listener);
+		Listener = -1;
+	}
+	return TRUE;
+}
+
+static PurplePluginPrefFrame *
+get_plugin_pref_frame(PurplePlugin *plugin)
+{
+	PurplePluginPrefFrame *frame;
+	PurplePluginPref *ppref;
+
+	frame = purple_plugin_pref_frame_new();
+
+	ppref = purple_plugin_pref_new_with_name_and_label("/plugins/core/alertcount/port", _("Listen on _port"));
+	purple_plugin_pref_frame_add(frame, ppref);
+
+	ppref = purple_plugin_pref_new_with_name_and_label("/plugins/core/alertcount/aggregate", _("_Aggregate conversation"));
+	purple_plugin_pref_frame_add(frame, ppref);
+
+	ppref = purple_plugin_pref_new_with_name_and_label("/plugins/core/alertcount/ident", _("_Identify conversations"));
+	purple_plugin_pref_frame_add(frame, ppref);
+
+	return frame;
+}
+
+static PurplePluginUiInfo prefs_info =
+{
+	get_plugin_pref_frame,
+	0,   /* page_num (Reserved) */
+	NULL, /* frame (Reserved) */
+	NULL,
+	NULL,
+	NULL,
+	NULL
+};
+
+static PurplePluginInfo info =
+{
+	PURPLE_PLUGIN_MAGIC,
+	PURPLE_MAJOR_VERSION,
+	PURPLE_MINOR_VERSION,
+	PURPLE_PLUGIN_STANDARD,                             /**< type           */
+	NULL,                                             /**< ui_requirement */
+	0,                                                /**< flags          */
+	NULL,                                             /**< dependencies   */
+	PURPLE_PRIORITY_DEFAULT,                            /**< priority       */
+
+	ALERTS_PLUGIN_ID,                                 /**< id             */
+	N_("Alert Count Server"),                              /**< name           */
+	DISPLAY_VERSION,                                  /**< version        */
+	                                                  /**  summary        */
+	N_("Exports unseen conversation count to a single network listener."),
+	                                                  /**  description    */
+	N_("Exports unseen conversation count to a single network listener."),
+	"Dylan Simon <dylan@dylex.net>",        /**< author         */
+	NULL,                                     /**< homepage       */
+
+	plugin_load,                                      /**< load           */
+	plugin_unload,                                    /**< unload         */
+	NULL,                                             /**< destroy        */
+
+	NULL,                                             /**< ui_info        */
+	NULL,                                             /**< extra_info     */
+	&prefs_info,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL
+};
+
+static void
+init_plugin(PurplePlugin *plugin)
+{
+	purple_prefs_add_none("/plugins/core/alertcount");
+	purple_prefs_add_int("/plugins/core/alertcount/port", 6652);
+	purple_prefs_add_bool("/plugins/core/alertcount/aggregate", TRUE);
+	purple_prefs_add_bool("/plugins/core/alertcount/ident", FALSE);
+}
+
+PURPLE_INIT_PLUGIN(alertcount, init_plugin, info)
diff --git a/libpurple/plugins/statelog.c b/libpurple/plugins/statelog.c
new file mode 100644
index 0000000000..174e03a5ff
--- /dev/null
+++ b/libpurple/plugins/statelog.c
@@ -0,0 +1,344 @@
+#include "internal.h"
+#include "debug.h"
+#include "plugin.h"
+#include "version.h"
+#include "blist.h"
+
+/** Plugin id : type-author-name (to guarantee uniqueness) */
+#define STATELOG_PLUGIN_ID "core-dylex-statelog"
+
+struct BuddyState {
+	time_t conn, idle;
+	gboolean away;
+	char *msg;
+};
+
+static GHashTable *buddy_states;
+
+static void buddy_state_free(struct BuddyState *bs)
+{
+	if (bs->msg)
+		g_free(bs->msg);
+	g_free(bs);
+}
+
+static char *msg_dup(const char *msg)
+{
+	gsize n = strlen(msg);
+	if (!strncasecmp(msg, "<html>", 6))
+	{
+		msg += 6;
+		n -= 6;
+	}
+	if (!strncasecmp(msg, "<body>", 6))
+	{
+		msg += 6;
+		n -= 6;
+	}
+	if (n >= 7 && !strncasecmp(msg+n-7, "</html>", 7))
+	{
+		n -= 7;
+	}
+	if (n >= 7 && !strncasecmp(msg+n-7, "</body>", 7))
+	{
+		n -= 7;
+	}
+	return g_strndup(msg, n);
+}
+
+static void
+update_state(PurpleBuddy *buddy) // , time_t when, const char *status, const char *msg)
+{
+	struct BuddyState *curr;
+	const char *who;
+	char *escaped;
+	const PurplePresence *presence;
+	const PurpleStatus *status;
+	time_t when = 0, conn, idle;
+	const char *msg;
+	gboolean away;
+	gboolean changed = FALSE;
+	GString *buf;
+
+	who = purple_buddy_get_alias(buddy);
+	escaped = g_markup_escape_text(who, -1);
+	buf = g_string_new(escaped);
+	g_free(escaped);
+
+	curr = g_hash_table_lookup(buddy_states, buddy);
+	if (!curr)
+	{
+		curr = g_new0(struct BuddyState, 1);
+		g_hash_table_insert(buddy_states, buddy, curr);
+	}
+
+	presence = purple_buddy_get_presence(buddy);
+	status = purple_presence_get_active_status(presence);
+
+	if (purple_presence_is_online(presence))
+	{
+		if (!(conn = purple_presence_get_login_time(presence)))
+			if (!(conn = curr->conn))
+				time(&conn);
+	}
+	else
+		conn = 0;
+	if (purple_prefs_get_bool("/plugins/core/statelog/log_conn")
+			&& conn != curr->conn)
+	{
+		if (conn)
+		{
+			when = conn;
+			g_string_append(buf, " <font color=\"yellow\">signon</font>");
+		}
+		else
+			g_string_append(buf, " <font color=\"red\">signoff</font>");
+		curr->conn = conn;
+		changed = TRUE;
+	}
+
+	if (purple_presence_is_idle(presence))
+	{
+		idle = purple_presence_get_idle_time(presence);
+		if (!idle) time(&idle);
+	}
+	else
+		idle = 0;
+	if (conn && purple_prefs_get_bool("/plugins/core/statelog/log_idle")
+			&& idle != curr->idle)
+	{
+		if (idle)
+		{
+			if (!when) when = idle;
+			g_string_append(buf, " <font color=\"cyan\">idle</font>");
+		}
+		else
+			g_string_append(buf, " unidle");
+		curr->idle = idle;
+		changed = TRUE;
+	}
+
+	if (conn && purple_prefs_get_bool("/plugins/core/statelog/log_away")
+			&& (away = !purple_status_is_available(status)) != curr->away)
+	{
+		if (away)
+			g_string_append_printf(buf, " <font color=\"green\">%s</font>", purple_status_get_name(status) ?: "away");
+		else
+			g_string_append_printf(buf, " %s", purple_status_get_name(status) ?: "back");
+		curr->away = away;
+		changed = TRUE;
+	}
+
+	if (purple_prefs_get_bool("/plugins/core/statelog/log_msg") 
+			&& (msg = purple_status_get_attr_string(status, "message"))
+			&& (!curr->msg || strcmp(msg, curr->msg)))
+	{
+		/* XXX clear if msg == NULL? */
+		gchar *cmsg = msg_dup(msg);
+		if (!curr->msg || strcmp(cmsg, curr->msg))
+		{
+			purple_debug_info("statelog", "changing msg from '%s' to '%s'\n", curr->msg, cmsg);
+			g_string_append_printf(buf, ": %s", cmsg);
+			if (curr->msg) g_free(curr->msg);
+			curr->msg = cmsg;
+			changed = TRUE;
+		}
+		else
+		{
+			g_free(cmsg);
+		}
+	}
+
+	if (!changed)
+	{
+		g_string_free(buf, TRUE);
+		return;
+	}
+
+	if (!when) time(&when);
+
+	if (purple_prefs_get_bool("/plugins/core/statelog/to_conv")) {
+		PurpleConversation *conv = purple_find_conversation_with_account(PURPLE_CONV_TYPE_IM, buddy->name, buddy->account);
+		if (conv && conv->type == PURPLE_CONV_TYPE_IM)
+			purple_conv_im_write(conv->u.im, NULL, buf->str, PURPLE_MESSAGE_SYSTEM | PURPLE_MESSAGE_ACTIVE_ONLY | PURPLE_MESSAGE_NO_LOG, when);
+	}
+
+	if (purple_prefs_get_bool("/plugins/core/statelog/collapsed") || !purple_blist_node_get_bool(&purple_buddy_get_group(buddy)->node, "collapsed"))
+	{
+		if (purple_prefs_get_bool("/plugins/core/statelog/to_acct")) {
+			PurpleLog *log = purple_account_get_log(buddy->account, FALSE);
+			if (log)
+				purple_log_write(log, PURPLE_MESSAGE_SYSTEM, who, when, buf->str);
+		}
+
+		if (purple_prefs_get_bool("/plugins/core/statelog/to_self")) {
+			PurpleConversation *conv = purple_find_conversation_with_account(PURPLE_CONV_TYPE_MISC, "state", buddy->account);
+			if (!conv)
+				conv = purple_conversation_new(PURPLE_CONV_TYPE_MISC, buddy->account, "state");
+			if (conv)
+				purple_conversation_write(conv, who, buf->str, PURPLE_MESSAGE_SYSTEM | PURPLE_MESSAGE_ACTIVE_ONLY, when);
+		}
+	}
+
+	g_string_free(buf, TRUE);
+}
+
+static void
+buddy_status_changed_cb(PurpleBuddy *buddy, PurpleStatus *old_status,
+                        PurpleStatus *status, void *data)
+{
+	update_state(buddy);
+}
+
+static void
+buddy_idle_changed_cb(PurpleBuddy *buddy, gboolean old_idle, gboolean idle,
+                      void *data)
+{
+	update_state(buddy);
+}
+
+static void
+buddy_signon_cb(PurpleBuddy *buddy, void *data)
+{
+	update_state(buddy);
+}
+
+static void
+buddy_signoff_cb(PurpleBuddy *buddy, void *data)
+{
+	update_state(buddy);
+}
+
+static PurplePluginPrefFrame *
+get_plugin_pref_frame(PurplePlugin *plugin)
+{
+	PurplePluginPrefFrame *frame;
+	PurplePluginPref *ppref;
+
+	frame = purple_plugin_pref_frame_new();
+
+	ppref = purple_plugin_pref_new_with_label(_("Log To"));
+	purple_plugin_pref_frame_add(frame, ppref);
+
+	ppref = purple_plugin_pref_new_with_name_and_label("/plugins/core/statelog/to_conv", _("_Buddy Conversation"));
+	purple_plugin_pref_frame_add(frame, ppref);
+
+	ppref = purple_plugin_pref_new_with_name_and_label("/plugins/core/statelog/to_acct", _("Account _Log"));
+	purple_plugin_pref_frame_add(frame, ppref);
+
+	ppref = purple_plugin_pref_new_with_name_and_label("/plugins/core/statelog/to_self", _("_State Conversation"));
+	purple_plugin_pref_frame_add(frame, ppref);
+
+	ppref = purple_plugin_pref_new_with_label(_("Log When"));
+	purple_plugin_pref_frame_add(frame, ppref);
+
+	ppref = purple_plugin_pref_new_with_name_and_label("/plugins/core/statelog/log_away", _("Buddy Goes _Away"));
+	purple_plugin_pref_frame_add(frame, ppref);
+
+	ppref = purple_plugin_pref_new_with_name_and_label("/plugins/core/statelog/log_idle", _("Buddy Goes _Idle"));
+	purple_plugin_pref_frame_add(frame, ppref);
+
+	ppref = purple_plugin_pref_new_with_name_and_label("/plugins/core/statelog/log_conn", _("Buddy _Connects/Disconnects"));
+	purple_plugin_pref_frame_add(frame, ppref);
+
+	ppref = purple_plugin_pref_new_with_name_and_label("/plugins/core/statelog/collapsed", _("Buddy in Collapsed _Group"));
+	purple_plugin_pref_frame_add(frame, ppref);
+
+	ppref = purple_plugin_pref_new_with_name_and_label("/plugins/core/statelog/log_msg", _("Include Status _Message"));
+	purple_plugin_pref_frame_add(frame, ppref);
+
+	return frame;
+}
+
+static gboolean
+plugin_load(PurplePlugin *plugin)
+{
+	void *blist_handle = purple_blist_get_handle();
+
+	buddy_states = g_hash_table_new_full(NULL, NULL, NULL, (GDestroyNotify)buddy_state_free);
+
+	purple_signal_connect(blist_handle, "buddy-status-changed", plugin,
+	                    PURPLE_CALLBACK(buddy_status_changed_cb), NULL);
+	purple_signal_connect(blist_handle, "buddy-idle-changed", plugin,
+	                    PURPLE_CALLBACK(buddy_idle_changed_cb), NULL);
+	purple_signal_connect(blist_handle, "buddy-signed-on", plugin,
+	                    PURPLE_CALLBACK(buddy_signon_cb), NULL);
+	purple_signal_connect(blist_handle, "buddy-signed-off", plugin,
+	                    PURPLE_CALLBACK(buddy_signoff_cb), NULL);
+
+	purple_debug_info("statelog", "statelog plugin loaded.\n");
+
+	return TRUE;
+}
+
+static gboolean
+plugin_unload(PurplePlugin *plugin)
+{
+	purple_debug_info("statelog", "statelog plugin unloaded.\n");
+
+	g_hash_table_destroy(buddy_states);
+
+	return TRUE;
+}
+
+static PurplePluginUiInfo prefs_info =
+{
+	get_plugin_pref_frame,
+	0,   /* page_num (Reserved) */
+	NULL, /* frame (Reserved) */
+	NULL,
+	NULL,
+	NULL,
+	NULL
+};
+
+static PurplePluginInfo info =
+{
+	PURPLE_PLUGIN_MAGIC,
+	PURPLE_MAJOR_VERSION,
+	PURPLE_MINOR_VERSION,
+	PURPLE_PLUGIN_STANDARD,                             /**< type           */
+	NULL,                                             /**< ui_requirement */
+	0,                                                /**< flags          */
+	NULL,                                             /**< dependencies   */
+	PURPLE_PRIORITY_DEFAULT,                            /**< priority       */
+
+	STATELOG_PLUGIN_ID,                                 /**< id             */
+	N_("State Logger"),                              /**< name           */
+	DISPLAY_VERSION,                                  /**< version        */
+	                                                  /**  summary        */
+	N_("Logs presence changes and away messages of buddies."),
+	                                                  /**  description    */
+	N_("Logs presence changes and away messages of buddies.  Based on statenotify."),
+	"Dylan Simon <dylan@dylex.net>",        /**< author         */
+	NULL,                                     /**< homepage       */
+
+	plugin_load,                                      /**< load           */
+	plugin_unload,                                    /**< unload         */
+	NULL,                                             /**< destroy        */
+
+	NULL,                                             /**< ui_info        */
+	NULL,                                             /**< extra_info     */
+	&prefs_info,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL
+};
+
+static void
+init_plugin(PurplePlugin *plugin)
+{
+	purple_prefs_add_none("/plugins/core/statelog");
+	purple_prefs_add_bool("/plugins/core/statelog/to_conv", TRUE);
+	purple_prefs_add_bool("/plugins/core/statelog/to_acct", FALSE);
+	purple_prefs_add_bool("/plugins/core/statelog/to_self", FALSE);
+	purple_prefs_add_bool("/plugins/core/statelog/log_away", TRUE);
+	purple_prefs_add_bool("/plugins/core/statelog/log_idle", FALSE);
+	purple_prefs_add_bool("/plugins/core/statelog/log_conn", TRUE);
+	purple_prefs_add_bool("/plugins/core/statelog/log_msg", FALSE);
+	purple_prefs_add_bool("/plugins/core/statelog/collapsed", FALSE);
+}
+
+PURPLE_INIT_PLUGIN(statelog, init_plugin, info)
diff --git a/libpurple/plugins/syncnotify.c b/libpurple/plugins/syncnotify.c
new file mode 100644
index 0000000000..646ed5321f
--- /dev/null
+++ b/libpurple/plugins/syncnotify.c
@@ -0,0 +1,95 @@
+#include "internal.h"
+#include "debug.h"
+#include "plugin.h"
+#include "version.h"
+#include "blist.h"
+
+/** Plugin id : type-author-name (to guarantee uniqueness) */
+#define NOTIFY_PLUGIN_ID "core-dylex-syncnotify"
+
+#define PATH "/home/dylan/.sync-notify"
+static const struct sockaddr_un ADDR = {
+	AF_UNIX,
+	"/home/dylan/.sync-notify"
+};
+
+static void
+conversation_created_cb(PurpleConversation *conv, void *data)
+{
+	if (conv->logs == NULL)
+		return;
+	PurpleLog *log = conv->logs->data;
+	if (log == NULL)
+		return;
+	int s = socket(AF_UNIX, SOCK_DGRAM, 0);
+	if (s < 0)
+	{
+		purple_debug_warning("syncnotify", "socket: %m\n");
+		return;
+	}
+	char *dir = purple_log_get_log_dir(log->type, log->name, log->account);
+	const struct tm *tm = localtime(&log->time);
+	const char *tz = purple_escape_filename(purple_utf8_strftime("%Z", tm));
+	const char *date = purple_utf8_strftime("%Y-%m-%d.%H%M%S%z", tm);
+	char *filename = g_strdup_printf("%s%s.html", date, tz);
+	const char *path = g_build_filename(dir, filename, NULL);
+	g_free(dir);
+	g_free(filename);
+	ssize_t r = sendto(s, path, strlen(path), 0, &ADDR, SUN_LEN(&ADDR)+1);
+	if (r < 0 && errno != ENOENT && errno != ECONNREFUSED)
+		purple_debug_warning("syncnotify", "sendto: %m\n");
+	close(s);
+}
+
+static gboolean
+plugin_load(PurplePlugin *plugin)
+{
+	purple_signal_connect(purple_conversations_get_handle(), "conversation-created", plugin,
+	                    PURPLE_CALLBACK(conversation_created_cb), NULL);
+
+	return TRUE;
+}
+
+static gboolean
+plugin_unload(PurplePlugin *plugin)
+{
+	return TRUE;
+}
+
+static PurplePluginInfo info =
+{
+	PURPLE_PLUGIN_MAGIC,
+	PURPLE_MAJOR_VERSION,
+	PURPLE_MINOR_VERSION,
+	PURPLE_PLUGIN_STANDARD,                             /**< type           */
+	NULL,                                             /**< ui_requirement */
+	0,                                                /**< flags          */
+	NULL,                                             /**< dependencies   */
+	PURPLE_PRIORITY_DEFAULT,                            /**< priority       */
+
+	NOTIFY_PLUGIN_ID,                                 /**< id             */
+	N_("Dylex Notifier"),                              /**< name           */
+	DISPLAY_VERSION,                                  /**< version        */
+	                                                  /**  summary        */
+	N_("Pushes relevant event notifications."),
+	                                                  /**  description    */
+	N_("Pushes relevant event notifications."),
+	"Dylan Simon <dylan@dylex.net>",        /**< author         */
+	NULL,                                     /**< homepage       */
+
+	plugin_load,                                      /**< load           */
+	plugin_unload,                                    /**< unload         */
+	NULL,                                             /**< destroy        */
+
+	NULL,                                             /**< ui_info        */
+	NULL,                                             /**< extra_info     */
+	NULL,
+	NULL
+};
+
+static void
+init_plugin(PurplePlugin *plugin)
+{
+}
+
+PURPLE_INIT_PLUGIN(notify, init_plugin, info)
