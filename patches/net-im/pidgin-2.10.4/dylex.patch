#
# old_revision [03f3e779309e683d092706d76a5253c6794d3a66]
#
# add_file "finch/gntimhtml.c"
#  content [ff1312c09d7ffe1a2114ad05a1bb85f3dfb83c57]
# 
# add_file "finch/gntimhtml.h"
#  content [0c5b961854c6265801f7efa7d9d6de30084d9e7c]
# 
# add_file "finch/libgnt/wms/full.c"
#  content [cf9a87b273887935415faba54ac9cc61d8f6ccca]
# 
# add_file "libpurple/plugins/statelog.c"
#  content [fa3ef8c31cbe2abf19d0608b9d7ba30a640493e2]
# 
# add_file "libpurple/plugins/syncnotify.c"
#  content [525b2b218d22dac8f58ecf8a162eed40b921b60f]
# 
# patch "Makefile.am"
#  from [8aa4636bb5ba663c31f0beb42d2bfb377f5a1303]
#    to [00a014fc0667540e65f0f599c33c05efa8d0f573]
# 
# patch "configure.ac"
#  from [f745dac9118aee975feba1c98f13de760f57eff0]
#    to [620e0231ad2565876ab3630eac936aa2259e89d8]
# 
# patch "finch/Makefile.am"
#  from [059853f082e9aff96218119a09d9e0bf75137cff]
#    to [da5ff3c9adfbb6b9eb34599891d275cc360f5939]
# 
# patch "finch/gntblist.c"
#  from [b84805c84bbdb9efc7f992128395b4f30b63c511]
#    to [50e3fb6a17b466821ea52964fc54119c283173d1]
# 
# patch "finch/gntconv.c"
#  from [311404c18dc02e5c09fecb58d100c6006530cdfa]
#    to [4ecd062639568382d0730832db0f0f474f8eecdc]
# 
# patch "finch/gntnotify.c"
#  from [b65450342112739956f94128f4c3cdf87d9236fd]
#    to [7ea6472bd58b333d8fd844674fc37db54b5f63f9]
# 
# patch "finch/gntprefs.c"
#  from [134b6f26598164780cd23e3160009dd78790d3ce]
#    to [d2d557a875044303463cdde394ec174226ee0c0f]
# 
# patch "finch/libgnt/Makefile.am"
#  from [f147cb3c3579ba533fe413ba157b6850b9f93e28]
#    to [fc645fb5993ba558413ce8796e564fe5af113634]
# 
# patch "finch/libgnt/gntcolors.c"
#  from [8a25be8f9a2a065f7b5c00a5efbdad7a920228be]
#    to [48da42e665385664fa7c76e1d87c07e3ec9dfc1c]
# 
# patch "finch/libgnt/gntcolors.h"
#  from [536808222410f1ed9c004e6c9f320f9249226346]
#    to [6d9e4e9cb2ea80ccfb08542fb5f14d9aecb30897]
# 
# patch "finch/libgnt/gnttextview.c"
#  from [1eb84985613a3e710d232c18b72d4665aafa64cc]
#    to [8a0f2b117cc66e8ffbcd74ec07d91b57cd2ff099]
# 
# patch "finch/libgnt/gntutils.c"
#  from [031bd6ec2bb227d2a283bb874ab87e14f0b109e0]
#    to [cb8762cf9faff35871bbdca97175166998bf214f]
# 
# patch "finch/libgnt/gntutils.h"
#  from [93b643e27c3571561bb425737a747476494b8ebe]
#    to [19e752852592c387ffcd394f2ca8d8a47edc3892]
# 
# patch "finch/libgnt/gntwidget.h"
#  from [e99942bee9da195bf60c8f51ce3016570457f863]
#    to [47b9a00e8d88f23f1a0363d9ba14c3af145560c4]
# 
# patch "finch/libgnt/gntwm.c"
#  from [b62ec012936d97aa1f1ae69b938963b3f1d01389]
#    to [37e704e379d3d6b35eb0b8eaf446709d7f690700]
# 
# patch "finch/libgnt/gntwm.h"
#  from [98eed7e0a99391a3453fa13d6919a88319231c26]
#    to [3658861bd0d77c40b3f2fa6d01ba7ddb38e92752]
# 
# patch "finch/libgnt/gntws.c"
#  from [2e65e911d7513fe9f8a4f40a4a6319b1baf00c1a]
#    to [8ed025c72b87bf82a7246b7937b60bb078326a69]
# 
# patch "finch/libgnt/gntws.h"
#  from [94e6e777c0ecc18e512049e146d808c9b162ba8d]
#    to [cfb55d0e60c0264a474aecd893d314671d3ee2b8]
# 
# patch "finch/libgnt/wms/Makefile.am"
#  from [84e899cd4d3f3b98492da6f4a30b81e73fcb10f5]
#    to [ba77e27e9a1281f63bf44b7ed6ca81e94490e962]
# 
# patch "libpurple/conversation.c"
#  from [19aac10ceebae1ee28788b6f0c02bcfcff0c8803]
#    to [a10bb2960806596594138879e718464af05cb718]
# 
# patch "libpurple/log.c"
#  from [0c3f25c46b130043aaa4f84bfcc5adf8156e6b2e]
#    to [f1c5f6abe3411addb4df0d359e24a4d6910fa294]
# 
# patch "libpurple/media/backend-fs2.h"
#  from [d0c98270d331a2386413bdc2057c6dac0da72c28]
#    to [906b0b66c244bffbb6f9164640bb6ef97f34f14b]
# 
# patch "libpurple/plugins/Makefile.am"
#  from [745b67aa56634bd2b67533d6be2a52ea55f01525]
#    to [59cd57ff3a14a15603d108737afcd6cccf254d5a]
#
============================================================
--- Makefile.am	8aa4636bb5ba663c31f0beb42d2bfb377f5a1303
+++ Makefile.am	00a014fc0667540e65f0f599c33c05efa8d0f573
@@ -1,4 +1,4 @@
-EXTRA_DIST = \
+EXTRA_DIST = config.rpath  \
 		COPYRIGHT \
 		ChangeLog.API \
 		ChangeLog.win32 \
@@ -145,3 +145,5 @@ DISTCLEANFILES= $(DESKTOP_FILE) libpurpl
 
 DISTCLEANFILES= $(DESKTOP_FILE) libpurple/gconf/purple.schemas intltool-extract \
 			intltool-merge intltool-update
+
+ACLOCAL_AMFLAGS = -I m4
============================================================
--- libpurple/conversation.c	19aac10ceebae1ee28788b6f0c02bcfcff0c8803
+++ libpurple/conversation.c	a10bb2960806596594138879e718464af05cb718
@@ -907,6 +907,7 @@ purple_find_conversation_with_account(Pu
 	switch (type) {
 		case PURPLE_CONV_TYPE_IM:
 		case PURPLE_CONV_TYPE_CHAT:
+		case PURPLE_CONV_TYPE_MISC:
 			c = g_hash_table_lookup(conversation_cache, &hc);
 			break;
 		case PURPLE_CONV_TYPE_ANY:
============================================================
--- configure.ac	f745dac9118aee975feba1c98f13de760f57eff0
+++ configure.ac	620e0231ad2565876ab3630eac936aa2259e89d8
@@ -299,36 +299,6 @@ AC_ARG_ENABLE(nls, AC_HELP_STRING([--dis
 dnl #######################################################################
 AC_ARG_ENABLE(nls, AC_HELP_STRING([--disable-nls], [disable installation of translation files]), enable_i18n="$enableval", enable_i18n=yes)
 
-if test x$enable_i18n = xyes; then
-	AC_PROG_INTLTOOL
-	GETTEXT_PACKAGE=pidgin
-	AC_SUBST(GETTEXT_PACKAGE)
-
-	ALL_LINGUAS="af am ar az be@latin bg bn bn_IN bs ca ca@valencia cs da de dz el en_AU en_CA en_GB eo es et eu fa fi fr ga gl gu he hi hr hu hy id it ja ka km kn ko ku lo lt mai mhr mk mn mr ms_MY my_MM nb ne nl nn oc or pa pl pt_BR pt ps ro ru si sk sl sq sr sr@latin sv sw ta te th tr uk ur vi xh zh_CN zh_HK zh_TW"
-	AM_GLIB_GNU_GETTEXT
-
-	dnl If we don't have msgfmt, then po/ is going to fail -- ensure that
-	dnl AM_GLIB_GNU_GETTEXT found it.
-
-	if test x$MSGFMT = xno -o x$MSGFMT$GMSGFMT$INTLTOOL_MSGFMT = x
-	then
-		AC_MSG_ERROR([
-
-The msgfmt command is required to build libpurple.  If it is installed
-on your system, ensure that it is in your path.  If it is not, install
-GNU gettext to continue.
-
-If you have msgfmt installed, but for some reason this error message
-is still displayed, you have encountered what appears to be a bug in
-third-party configure macros.  Try setting the MSGFMT environment
-variable to the absolute path to your msgfmt binary and trying
-configure again, like this:
-
-MSGFMT=/path/to/msgfmt ./configure ...
-	])
-	fi
-fi #enable_i18n
-
 AM_CONDITIONAL(INSTALL_I18N, test "x$enable_i18n" = "xyes")
 
 dnl #######################################################################
@@ -1413,7 +1383,7 @@ if test "x$enable_dbus" = "xyes" || test
 
 if test "x$enable_dbus" = "xyes" || test "x$enable_consoleui" = "xyes" ; then
 	if test -z "$PYTHON" -o "x$PYTHON" = "xyes"; then
-		AC_PATH_PROG([PYTHON], [python], [no])
+	AC_PATH_PROG([PYTHON], [python], [no])
 	fi
 
 	if test x"$PYTHON" = x"no" ; then
============================================================
--- libpurple/log.c	0c3f25c46b130043aaa4f84bfcc5adf8156e6b2e
+++ libpurple/log.c	f1c5f6abe3411addb4df0d359e24a4d6910fa294
@@ -51,6 +51,7 @@ static void log_get_log_sets_common(GHas
 
 static void log_get_log_sets_common(GHashTable *sets);
 
+static void html_logger_create(PurpleLog *log);
 static gsize html_logger_write(PurpleLog *log, PurpleMessageFlags type,
 							  const char *from, time_t time, const char *message);
 static void html_logger_finalize(PurpleLog *log);
@@ -66,6 +67,7 @@ static void old_logger_finalize(PurpleLo
 static void old_logger_get_log_sets(PurpleLogSetCallback cb, GHashTable *sets);
 static void old_logger_finalize(PurpleLog *log);
 
+static void txt_logger_create(PurpleLog *log);
 static gsize txt_logger_write(PurpleLog *log,
 							 PurpleMessageFlags type,
 							 const char *from, time_t time, const char *message);
@@ -653,7 +655,7 @@ void purple_log_init(void)
 	purple_prefs_add_string("/purple/logging/format", "html");
 
 	html_logger = purple_log_logger_new("html", _("HTML"), 11,
-									  NULL,
+									  html_logger_create,
 									  html_logger_write,
 									  html_logger_finalize,
 									  html_logger_list,
@@ -667,7 +669,7 @@ void purple_log_init(void)
 	purple_log_logger_add(html_logger);
 
 	txt_logger = purple_log_logger_new("txt", _("Plain text"), 11,
-									 NULL,
+									 txt_logger_create,
 									 txt_logger_write,
 									 txt_logger_finalize,
 									 txt_logger_list,
@@ -755,7 +757,7 @@ static char *log_get_timestamp(PurpleLog
 	char *date;
 	struct tm tm;
 
-	show_date = (log->type == PURPLE_LOG_SYSTEM) || (time(NULL) > when + 20*60);
+	show_date = TRUE;
 
 	date = purple_signal_emit_return_1(purple_log_get_handle(),
 	                          "log-timestamp",
@@ -1369,14 +1371,9 @@ static PurpleLogLogger xml_logger =  {
  ** HTML LOGGER *************
  ****************************/
 
-static gsize html_logger_write(PurpleLog *log, PurpleMessageFlags type,
-							  const char *from, time_t time, const char *message)
+static void html_logger_create(PurpleLog *log)
 {
-	char *msg_fixed;
-	char *image_corrected_msg;
-	char *date;
 	char *header;
-	char *escaped_from;
 	PurplePlugin *plugin = purple_find_prpl(purple_account_get_protocol_id(log->account));
 	PurpleLogCommonLoggerData *data = log->logger_data;
 	gsize written = 0;
@@ -1391,7 +1388,7 @@ static gsize html_logger_write(PurpleLog
 
 		/* if we can't write to the file, give up before we hurt ourselves */
 		if(!data->file)
-			return 0;
+			return;
 
 		date = purple_date_format_full(localtime(&log->time));
 
@@ -1410,7 +1407,23 @@ static gsize html_logger_write(PurpleLog
 		written += fprintf(data->file, "<h3>%s</h3>\n", header);
 		g_free(header);
 	}
+}
 
+static gsize html_logger_write(PurpleLog *log, PurpleMessageFlags type,
+							  const char *from, time_t time, const char *message)
+{
+	char *msg_fixed;
+	char *image_corrected_msg;
+	char *date;
+	char *escaped_from;
+	PurpleLogCommonLoggerData *data = log->logger_data;
+	gsize written = 0;
+
+	if(!data) {
+		html_logger_create(log);
+		data = log->logger_data;
+	}
+
 	/* if we can't write to the file, give up before we hurt ourselves */
 	if(!data->file)
 		return 0;
@@ -1527,15 +1540,10 @@ static int html_logger_total_size(Purple
  ** PLAIN TEXT LOGGER *******
  ****************************/
 
-static gsize txt_logger_write(PurpleLog *log,
-							 PurpleMessageFlags type,
-							 const char *from, time_t time, const char *message)
+static void txt_logger_create(PurpleLog *log)
 {
-	char *date;
 	PurplePlugin *plugin = purple_find_prpl(purple_account_get_protocol_id(log->account));
 	PurpleLogCommonLoggerData *data = log->logger_data;
-	char *stripped = NULL;
-
 	gsize written = 0;
 
 	if (data == NULL) {
@@ -1551,7 +1559,7 @@ static gsize txt_logger_write(PurpleLog 
 
 		/* if we can't write to the file, give up before we hurt ourselves */
 		if(!data->file)
-			return 0;
+			return;
 
 		if (log->type == PURPLE_LOG_SYSTEM)
 			written += fprintf(data->file, "System log for account %s (%s) connected at %s\n",
@@ -1562,7 +1570,23 @@ static gsize txt_logger_write(PurpleLog 
 				log->name, purple_date_format_full(localtime(&log->time)),
 				purple_account_get_username(log->account), prpl);
 	}
+}
 
+static gsize txt_logger_write(PurpleLog *log,
+							 PurpleMessageFlags type,
+							 const char *from, time_t time, const char *message)
+{
+	char *date;
+	PurpleLogCommonLoggerData *data = log->logger_data;
+	char *stripped = NULL;
+
+	gsize written = 0;
+
+	if (data == NULL) {
+		txt_logger_create(log);
+		data = log->logger_data;
+	}
+
 	/* if we can't write to the file, give up before we hurt ourselves */
 	if(!data->file)
 		return 0;
============================================================
--- finch/gntblist.c	b84805c84bbdb9efc7f992128395b4f30b63c511
+++ finch/gntblist.c	50e3fb6a17b466821ea52964fc54119c283173d1
@@ -2764,6 +2764,55 @@ block_select(GntMenuItem *item, gpointer
 						NULL);
 }
 
+static void
+privacy_select_cb(gpointer data, PurpleRequestFields *fields)
+{
+	PurpleAccount *account = purple_request_fields_get_account(fields, "account");
+	if (account) {
+		account->perm_deny = purple_request_fields_get_choice(fields, "privacy");
+		serv_set_permit_deny(purple_account_get_connection(account));
+	}
+}
+
+static void
+privacy_select(GntMenuItem *item, gpointer n)
+{
+	PurpleRequestFields *fields;
+	PurpleRequestFieldGroup *group;
+	PurpleRequestField *field;
+
+	fields = purple_request_fields_new();
+
+	group = purple_request_field_group_new(NULL);
+	purple_request_fields_add_group(fields, group);
+
+	field = purple_request_field_account_new("account", _("Account"), NULL);
+	purple_request_field_set_type_hint(field, "account");
+	purple_request_field_set_visible(field,
+		(purple_connections_get_all() != NULL &&
+		 purple_connections_get_all()->next != NULL));
+	purple_request_field_set_required(field, TRUE);
+	purple_request_field_group_add_field(group, field);
+
+	field = purple_request_field_choice_new("privacy", _("Privacy"), 1);
+	/* these are assumed to be in PurplePrivacyType order */
+	purple_request_field_choice_add(field, _("Allow all"));
+	purple_request_field_choice_add(field, _("Allow only buddy list"));
+	purple_request_field_choice_add(field, _("Allow only unblocked"));
+	purple_request_field_choice_add(field, _("Deny all"));
+	purple_request_field_choice_add(field, _("Deny only blocked"));
+	purple_request_field_group_add_field(group, field);
+
+	purple_request_fields(purple_get_blist(), _("Set"),
+						NULL,
+						_("Select which users may contact you on the specified account."),
+						fields,
+						_("OK"), G_CALLBACK(privacy_select_cb),
+						_("Cancel"), NULL,
+						NULL, NULL, NULL,
+						NULL);
+}
+
 /* send_im_select* -- Xerox */
 static void
 send_im_select_cb(gpointer data, PurpleRequestFields *fields)
@@ -3012,6 +3061,11 @@ create_menu(void)
 	gnt_menu_add_item(GNT_MENU(sub), item);
 	gnt_menuitem_set_callback(GNT_MENU_ITEM(item), block_select, NULL);
 
+	item = gnt_menuitem_new(_("Privacy..."));
+	gnt_menuitem_set_id(GNT_MENU_ITEM(item), "privacy");
+	gnt_menu_add_item(GNT_MENU(sub), item);
+	gnt_menuitem_set_callback(GNT_MENU_ITEM(item), privacy_select, NULL);
+
 	item = gnt_menuitem_new(_("Join Chat..."));
 	gnt_menuitem_set_id(GNT_MENU_ITEM(item), "join-chat");
 	gnt_menu_add_item(GNT_MENU(sub), item);
============================================================
--- finch/libgnt/gntcolors.c	8a25be8f9a2a065f7b5c00a5efbdad7a920228be
+++ finch/libgnt/gntcolors.c	48da42e665385664fa7c76e1d87c07e3ec9dfc1c
@@ -38,23 +38,27 @@ static gboolean hascolors;
 #include <string.h>
 
 static gboolean hascolors;
+static int bg_color = -1;
 static int custom_type = GNT_COLORS;
+#define MAX_COLORS 256
 static struct
 {
+	gboolean i;
 	short r, g, b;
-} colors[GNT_TOTAL_COLORS];
+	gboolean o;
+	short or, og, ob;
+} colors[MAX_COLORS] = {
+	/* assume default colors */
+	{ 1, 0, 0, 0, 0 },
+	{ 1, 1000, 0, 0, 0 },
+	{ 1, 0, 1000, 0, 0 },
+	{ 1, 1000, 1000, 0, 0 },
+	{ 1, 0, 0, 1000, 0 },
+	{ 1, 1000, 0, 1000, 0 },
+	{ 1, 0, 1000, 1000, 0 },
+	{ 1, 1000, 1000, 1000, 0 }
+};
 
-static void
-backup_colors(void)
-{
-	short i;
-	for (i = 0; i < GNT_TOTAL_COLORS; i++)
-	{
-		color_content(i, &colors[i].r,
-				&colors[i].g, &colors[i].b);
-	}
-}
-
 static gboolean
 can_use_custom_color(void)
 {
@@ -65,10 +69,10 @@ restore_colors(void)
 restore_colors(void)
 {
 	short i;
-	for (i = 0; i < GNT_TOTAL_COLORS; i++)
+	for (i = 0; i < MAX_COLORS; i++)
 	{
-		init_color(i, colors[i].r,
-				colors[i].g, colors[i].b);
+		if (colors[i].o)
+			init_color(i, colors[i].or, colors[i].og, colors[i].ob);
 	}
 }
 
@@ -76,6 +80,7 @@ void gnt_init_colors()
 {
 	static gboolean init = FALSE;
 	int defaults;
+	int c;
 
 	if (init)
 		return;
@@ -86,53 +91,26 @@ void gnt_init_colors()
 		return;
 	defaults = use_default_colors();
 
-	if (can_use_custom_color())
-	{
-		backup_colors();
-
-		/* Do some init_color()s */
-		init_color(GNT_COLOR_BLACK, 0, 0, 0);
-		init_color(GNT_COLOR_RED, 1000, 0, 0);
-		init_color(GNT_COLOR_GREEN, 0, 1000, 0);
-		init_color(GNT_COLOR_BLUE, 250, 250, 700);
-		init_color(GNT_COLOR_WHITE, 1000, 1000, 1000);
-		init_color(GNT_COLOR_GRAY, 699, 699, 699);
-		init_color(GNT_COLOR_DARK_GRAY, 256, 256, 256);
-
-		/* Now some init_pair()s */
-		init_pair(GNT_COLOR_NORMAL, GNT_COLOR_BLACK, GNT_COLOR_WHITE);
-		init_pair(GNT_COLOR_HIGHLIGHT, GNT_COLOR_WHITE, GNT_COLOR_BLUE);
-		init_pair(GNT_COLOR_SHADOW, GNT_COLOR_BLACK, GNT_COLOR_DARK_GRAY);
-
-		init_pair(GNT_COLOR_TITLE, GNT_COLOR_WHITE, GNT_COLOR_BLUE);
-		init_pair(GNT_COLOR_TITLE_D, GNT_COLOR_WHITE, GNT_COLOR_GRAY);
-
-		init_pair(GNT_COLOR_TEXT_NORMAL, GNT_COLOR_WHITE, GNT_COLOR_BLUE);
-		init_pair(GNT_COLOR_HIGHLIGHT_D, GNT_COLOR_BLACK, GNT_COLOR_GRAY);
-		init_pair(GNT_COLOR_DISABLED, GNT_COLOR_GRAY, GNT_COLOR_WHITE);
-		init_pair(GNT_COLOR_URGENT, GNT_COLOR_WHITE, GNT_COLOR_RED);
+	if (defaults == OK) {
+		bg_color = -1;
+		init_pair(GNT_COLOR_NORMAL, -1, bg_color);
+	} else {
+		bg_color = COLOR_WHITE;
+		init_pair(GNT_COLOR_NORMAL, COLOR_BLACK, bg_color);
 	}
-	else
-	{
-		int bg;
 
-		if (defaults == OK) {
-			init_pair(GNT_COLOR_NORMAL, -1, -1);
-			bg = -1;
-		} else {
-			init_pair(GNT_COLOR_NORMAL, COLOR_BLACK, COLOR_WHITE);
-			bg = COLOR_WHITE;
-		}
-		init_pair(GNT_COLOR_DISABLED, COLOR_YELLOW, bg);
-		init_pair(GNT_COLOR_URGENT, COLOR_GREEN, bg);
+	for (c = 1; c < GNT_COLOR_NORMAL; c ++)
+		init_pair(c, c, bg_color);
 
-		init_pair(GNT_COLOR_HIGHLIGHT, COLOR_WHITE, COLOR_BLUE);
-		init_pair(GNT_COLOR_SHADOW, COLOR_BLACK, COLOR_BLACK);
-		init_pair(GNT_COLOR_TITLE, COLOR_WHITE, COLOR_BLUE);
-		init_pair(GNT_COLOR_TITLE_D, COLOR_WHITE, COLOR_BLACK);
-		init_pair(GNT_COLOR_TEXT_NORMAL, COLOR_WHITE, COLOR_BLUE);
-		init_pair(GNT_COLOR_HIGHLIGHT_D, COLOR_CYAN, COLOR_BLACK);
-	}
+	init_pair(GNT_COLOR_DISABLED, COLOR_YELLOW, bg_color);
+	init_pair(GNT_COLOR_URGENT, COLOR_GREEN, bg_color);
+
+	init_pair(GNT_COLOR_HIGHLIGHT, COLOR_WHITE, COLOR_BLUE);
+	init_pair(GNT_COLOR_SHADOW, COLOR_BLACK, COLOR_BLACK);
+	init_pair(GNT_COLOR_TITLE, COLOR_WHITE, COLOR_BLUE);
+	init_pair(GNT_COLOR_TITLE_D, COLOR_WHITE, COLOR_BLACK);
+	init_pair(GNT_COLOR_TEXT_NORMAL, COLOR_WHITE, COLOR_BLUE);
+	init_pair(GNT_COLOR_HIGHLIGHT_D, COLOR_CYAN, COLOR_BLACK);
 }
 
 void
@@ -147,31 +125,34 @@ gnt_colors_get_color(char *key)
 gnt_colors_get_color(char *key)
 {
 	int color;
-	gboolean custom = can_use_custom_color();
 
 	key = g_strstrip(key);
 
 	if (strcmp(key, "black") == 0)
-		color = custom ? GNT_COLOR_BLACK : COLOR_BLACK;
+		color = COLOR_BLACK;
 	else if (strcmp(key, "red") == 0)
-		color = custom ? GNT_COLOR_RED : COLOR_RED;
+		color = COLOR_RED;
 	else if (strcmp(key, "green") == 0)
-		color = custom ? GNT_COLOR_GREEN : COLOR_GREEN;
+		color = COLOR_GREEN;
+	else if (strcmp(key, "yellow") == 0)
+		color = COLOR_YELLOW;
 	else if (strcmp(key, "blue") == 0)
-		color = custom ? GNT_COLOR_BLUE : COLOR_BLUE;
-	else if (strcmp(key, "white") == 0)
-		color = custom ? GNT_COLOR_WHITE : COLOR_WHITE;
-	else if (strcmp(key, "gray") == 0 || strcmp(key, "grey") == 0)
-		color = custom ? GNT_COLOR_GRAY : COLOR_YELLOW;  /* eh? */
-	else if (strcmp(key, "darkgray") == 0 || strcmp(key, "darkgrey") == 0)
-		color = custom ? GNT_COLOR_DARK_GRAY : COLOR_BLACK;
+		color = COLOR_BLUE;
 	else if (strcmp(key, "magenta") == 0)
 		color = COLOR_MAGENTA;
 	else if (strcmp(key, "cyan") == 0)
 		color = COLOR_CYAN;
+	else if (strcmp(key, "white") == 0)
+		color = COLOR_WHITE;
 	else if (strcmp(key, "default") == 0)
 		color = -1;
 	else {
+		if (strncmp(key, "color", 5) == 0)
+		{
+			color = atoi(&key[5]);
+			if (color > 0 && color < COLORS && color < MAX_COLORS)
+				return color;
+		}
 		g_warning("Invalid color name: %s\n", key);
 		color = -EINVAL;
 	}
@@ -213,7 +194,17 @@ void gnt_colors_parse(GKeyFile *kfile)
 					continue;
 				}
 
-				init_color(color, r, g, b);
+				if (!colors[color].o)
+				{
+					colors[color].o = color_content(color, &colors[color].or, &colors[color].og, &colors[color].ob) != ERR;
+				}
+				if (init_color(color, r, g, b) != ERR)
+				{
+					colors[color].i = 1;
+					colors[color].r = r;
+					colors[color].g = g;
+					colors[color].b = b;
+				}
 			}
 			g_strfreev(list);
 		}
@@ -304,6 +295,8 @@ int gnt_color_add_pair(int fg, int bg)
 
 int gnt_color_add_pair(int fg, int bg)
 {
+	if (bg == -1)
+		bg = bg_color;
 	init_pair(custom_type, fg, bg);
 	return custom_type++;
 }
============================================================
--- finch/libgnt/gntcolors.h	536808222410f1ed9c004e6c9f320f9249226346
+++ finch/libgnt/gntcolors.h	6d9e4e9cb2ea80ccfb08542fb5f14d9aecb30897
@@ -34,7 +34,16 @@ typedef enum
  */
 typedef enum
 {
-	GNT_COLOR_NORMAL = 1,
+	GNT_COLOR_BLACK = 0,
+	GNT_COLOR_RED,
+	GNT_COLOR_GREEN,
+	GNT_COLOR_YELLOW,
+	GNT_COLOR_BLUE,
+	GNT_COLOR_MAGENTA,
+	GNT_COLOR_CYAN,
+	GNT_COLOR_WHITE,
+
+	GNT_COLOR_NORMAL,
 	GNT_COLOR_HIGHLIGHT,		/* eg. when a button is selected */
 	GNT_COLOR_DISABLED,		/* eg. when a button is disabled */
 	GNT_COLOR_HIGHLIGHT_D,	/* eg. when a button is selected, but some other window is in focus */
@@ -49,18 +58,6 @@ typedef enum
 	GNT_COLORS
 } GntColorType;
 
-enum
-{
-	GNT_COLOR_BLACK = 0,
-	GNT_COLOR_RED,
-	GNT_COLOR_GREEN,
-	GNT_COLOR_BLUE,
-	GNT_COLOR_WHITE,
-	GNT_COLOR_GRAY,
-	GNT_COLOR_DARK_GRAY,
-	GNT_TOTAL_COLORS
-};
-
 /**
  * Initialize the colors.
  */
@@ -122,4 +119,5 @@ int gnt_color_add_pair(int fg, int bg);
  * @since 2.4.0
  */
 int gnt_color_add_pair(int fg, int bg);
+
 #endif
============================================================
--- finch/libgnt/gntwidget.h	e99942bee9da195bf60c8f51ce3016570457f863
+++ finch/libgnt/gntwidget.h	47b9a00e8d88f23f1a0363d9ba14c3af145560c4
@@ -66,6 +66,7 @@ typedef enum _GntWidgetFlags
 	GNT_WIDGET_INVISIBLE      = 1 << 10,
 	GNT_WIDGET_TRANSIENT      = 1 << 11,
 	GNT_WIDGET_DISABLE_ACTIONS = 1 << 12,
+	GNT_WIDGET_SWITCH_SKIP	  = 1 << 13,
 } GntWidgetFlags;
 
 /* XXX: This will probably move elsewhere */
@@ -103,6 +104,7 @@ struct _GntWidget
 
 	GntWidgetPriv priv;
 	WINDOW *window;
+	struct _GntNode *wmnode;
 
     void (*gnt_reserved1)(void);
     void (*gnt_reserved2)(void);
============================================================
--- finch/libgnt/gnttextview.c	1eb84985613a3e710d232c18b72d4665aafa64cc
+++ finch/libgnt/gnttextview.c	8a0f2b117cc66e8ffbcd74ec07d91b57cd2ff099
@@ -74,6 +74,13 @@ static void
 }
 
 static void
+gnt_text_view_draw_text(GntWidget *widget, GntTextFormatFlags fl, chtype at, char *s, char *e)
+{
+	wattrset(widget->window, at);
+	waddnstr(widget->window, s, e-s);
+}
+
+static void
 gnt_text_view_draw(GntWidget *widget)
 {
 	GntTextView *view = GNT_TEXT_VIEW(widget);
@@ -111,36 +118,26 @@ gnt_text_view_draw(GntWidget *widget)
 		for (iter = line->segments; iter; iter = iter->next)
 		{
 			GntTextSegment *seg = iter->data;
+			char *start = view->string->str + seg->start;
 			char *end = view->string->str + seg->end;
-			char back = *end;
-			chtype fl = seg->flags;
-			*end = '\0';
-			if (select_start && select_start < view->string->str + seg->start && select_end > view->string->str + seg->end) {
-				fl |= A_REVERSE;
-				wattrset(widget->window, fl);
-				wprintw(widget->window, "%s", C_(view->string->str + seg->start));
-			} else if (select_start && select_end &&
-				((select_start >= view->string->str + seg->start && select_start <= view->string->str + seg->end) ||
-				(select_end <= view->string->str + seg->end && select_start <= view->string->str + seg->start))) {
-				char *cur = view->string->str + seg->start;
-				while (*cur != '\0') {
-					gchar *last = g_utf8_next_char(cur);
-					gchar *str;
-					if (cur >= select_start && cur <= select_end)
-						fl |= A_REVERSE;
-					else
-						fl = seg->flags;
-					str = g_strndup(cur, last - cur);
-					wattrset(widget->window, fl);
-					waddstr(widget->window, C_(str));
-					g_free(str);
-					cur = g_utf8_next_char(cur);
-				}
-			} else {
-				wattrset(widget->window, fl);
-				wprintw(widget->window, "%s", C_(view->string->str + seg->start));
+			GntTextFormatFlags fl = seg->tvflag;
+			chtype at = seg->flags;
+			if (select_start && select_end && select_start < end && select_end >= start)
+			{
+				char *s = start;
+				char *e = select_start;
+				if (e > s)
+					gnt_text_view_draw_text(widget, fl, at, s, e);
+				s = MAX(select_start, start);
+				e = MIN(select_end+1, end);
+				gnt_text_view_draw_text(widget, fl, at | A_REVERSE, s, e);
+				s = select_end+1;
+				e = end;
+				if (e > s)
+					gnt_text_view_draw_text(widget, fl, at, s, e);
 			}
-			*end = back;
+			else
+				gnt_text_view_draw_text(widget, fl, at, start, end);
 		}
 		wattroff(widget->window, A_UNDERLINE | A_BLINK | A_REVERSE);
 		whline(widget->window, ' ', widget->priv.width - line->length - has_scroll);
@@ -660,10 +657,10 @@ chtype gnt_text_format_flag_to_chtype(Gn
 		fl |= A_UNDERLINE;
 	if (flags & GNT_TEXT_FLAG_BLINK)
 		fl |= A_BLINK;
-
 	if (flags & GNT_TEXT_FLAG_DIM)
-		fl |= (A_DIM | gnt_color_pair(GNT_COLOR_DISABLED));
-	else if (flags & GNT_TEXT_FLAG_HIGHLIGHT)
+		fl |= A_DIM;
+
+	if (flags & GNT_TEXT_FLAG_HIGHLIGHT)
 		fl |= (A_DIM | gnt_color_pair(GNT_COLOR_HIGHLIGHT));
 	else if ((flags & A_COLOR) == 0)
 		fl |= gnt_color_pair(GNT_COLOR_NORMAL);
============================================================
--- finch/gntconv.c	311404c18dc02e5c09fecb58d100c6006530cdfa
+++ finch/gntconv.c	4ecd062639568382d0730832db0f0f474f8eecdc
@@ -44,6 +44,7 @@
 #include "gntrequest.h"
 #include "gntsound.h"
 #include "gntstatus.h"
+#include "gntimhtml.h"
 
 #include "gnt.h"
 #include "gntbox.h"
@@ -150,7 +151,7 @@ entry_key_pressed(GntWidget *w, FinchCon
 		char *error = NULL, *escape;
 
 		escape = g_markup_escape_text(cmdline, -1);
-		status = purple_cmd_do_command(conv, cmdline, escape, &error);
+		status = purple_cmd_do_command(conv, escape, cmdline, &error);
 		g_free(escape);
 
 		switch (status)
@@ -906,7 +907,7 @@ finch_write_common(PurpleConversation *c
 		PurpleMessageFlags flags, time_t mtime)
 {
 	FinchConv *ggconv = FINCH_GET_DATA(conv);
-	char *strip, *newline;
+	char *strip;
 	GntTextFormatFlags fl = 0;
 	int pos;
 
@@ -933,7 +934,7 @@ finch_write_common(PurpleConversation *c
 		if (!mtime)
 			time(&mtime);
 		gnt_text_view_append_text_with_flags(GNT_TEXT_VIEW(ggconv->tv),
-					purple_utf8_strftime("(%H:%M:%S)", localtime(&mtime)), gnt_color_pair(color_timestamp));
+					purple_utf8_strftime(purple_prefs_get_string("/finch/conversations/timestamp_fmt"), localtime(&mtime)), gnt_color_pair(color_timestamp));
 	}
 
 	gnt_text_view_append_text_with_flags(GNT_TEXT_VIEW(ggconv->tv), " ", GNT_TEXT_FLAG_NORMAL);
@@ -976,15 +977,8 @@ finch_write_common(PurpleConversation *c
 	if (flags & PURPLE_MESSAGE_ERROR)
 		fl |= GNT_TEXT_FLAG_BOLD;
 
-	/* XXX: Remove this workaround when textview can parse messages. */
-	newline = purple_strdup_withhtml(message);
-	strip = purple_markup_strip_html(newline);
-	gnt_text_view_append_text_with_flags(GNT_TEXT_VIEW(ggconv->tv),
-				strip, fl);
+	gnt_imhtml_append_markup(GNT_TEXT_VIEW(ggconv->tv), message, fl);
 
-	g_free(newline);
-	g_free(strip);
-
 	if (purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_IM &&
 			purple_conv_im_get_typing_state(PURPLE_CONV_IM(conv)) == PURPLE_TYPING) {
 		strip = g_strdup_printf(_("\n%s is typing..."), purple_conversation_get_title(conv));
============================================================
--- finch/libgnt/Makefile.am	f147cb3c3579ba533fe413ba157b6850b9f93e28
+++ finch/libgnt/Makefile.am	fc645fb5993ba558413ce8796e564fe5af113634
@@ -10,8 +10,8 @@ BUILT_SOURCES = gntmarshal.h
 
 BUILT_SOURCES = gntmarshal.h
 
+nodist_libgnt_la_SOURCES = gntmarshal.c
 libgnt_la_SOURCES = \
-	gntmarshal.c \
 	gntwidget.c \
 	gntbindable.c \
 	gntbox.c \
@@ -53,7 +53,6 @@ libgnt_la_headers = \
 	gntkeys.h \
 	gntlabel.h \
 	gntline.h \
-	gntmarshal.h \
 	gntmenu.h \
 	gntmenuitem.h \
 	gntmenuitemcheck.h \
@@ -80,6 +79,7 @@ libgnt_laincludedir=$(includedir)/gnt
 	glib-genmarshal --prefix=gnt_closure_marshal --header $(srcdir)/genmarshal > $@
 
 libgnt_laincludedir=$(includedir)/gnt
+nodist_libgnt_lainclude_HEADERS = gntmarshal.h
 libgnt_lainclude_HEADERS = \
 	$(libgnt_la_headers)
 
============================================================
--- finch/gntnotify.c	b65450342112739956f94128f4c3cdf87d9236fd
+++ finch/gntnotify.c	7ea6472bd58b333d8fd844674fc37db54b5f63f9
@@ -96,7 +96,7 @@ finch_notify_message(PurpleNotifyMsgType
 			switch (type) {
 				case PURPLE_NOTIFY_FORMATTED:
 					plain = purple_markup_strip_html(secondary);
-					if (gnt_util_parse_xhtml_to_textview(secondary, GNT_TEXT_VIEW(msg)))
+					if (gnt_util_parse_xhtml_to_textview(secondary, GNT_TEXT_VIEW(msg), 0))
 						break;
 					/* Fallthrough */
 				default:
@@ -344,7 +344,7 @@ finch_notify_userinfo(PurpleConnection *
 		gnt_widget_get_size(GNT_WIDGET(msg), &tvw, &tvh);
 
 		gnt_text_view_clear(msg);
-		if (!gnt_util_parse_xhtml_to_textview(info, msg))
+		if (!gnt_util_parse_xhtml_to_textview(info, msg, 0))
 			gnt_text_view_append_text_with_flags(msg, strip, GNT_TEXT_FLAG_NORMAL);
 		gnt_text_view_scroll(msg, 0);
 		gnt_util_get_text_bound(strip, &ntvw, &ntvh);
============================================================
--- finch/gntprefs.c	134b6f26598164780cd23e3160009dd78790d3ce
+++ finch/gntprefs.c	d2d557a875044303463cdde394ec174226ee0c0f
@@ -53,11 +53,11 @@ void finch_prefs_init()
 
 	purple_prefs_add_none("/finch/conversations");
 	purple_prefs_add_bool("/finch/conversations/timestamps", TRUE);
+	purple_prefs_add_string("/finch/conversations/timestamp_fmt", "(%H:%M:%S)");
 	purple_prefs_add_bool("/finch/conversations/notify_typing", FALSE);
 
 	purple_prefs_add_none("/finch/filelocations");
 	purple_prefs_add_path("/finch/filelocations/last_save_folder", "");
-	purple_prefs_add_path("/finch/filelocations/last_save_folder", "");
 }
 
 void finch_prefs_update_old()
@@ -190,6 +190,7 @@ static Prefs convs[] =
 static Prefs convs[] =
 {
 	{PURPLE_PREF_BOOLEAN, "/finch/conversations/timestamps", N_("Show Timestamps"), NULL},
+	{PURPLE_PREF_STRING, "/finch/conversations/timestamp_fmt", N_("Timestamp Format"), NULL},
 	{PURPLE_PREF_BOOLEAN, "/finch/conversations/notify_typing", N_("Notify buddies when you are typing"), NULL},
 	{PURPLE_PREF_NONE, NULL, NULL, NULL}
 };
============================================================
--- finch/libgnt/gntutils.c	031bd6ec2bb227d2a283bb874ab87e14f0b109e0
+++ finch/libgnt/gntutils.c	cb8762cf9faff35871bbdca97175166998bf214f
@@ -41,6 +41,7 @@
 #include <stdlib.h>
 #include <string.h>
 
+#include "libpurple/util.h"
 #ifndef NO_LIBXML
 #include <libxml/parser.h>
 #include <libxml/tree.h>
@@ -389,7 +390,11 @@ util_parse_html_to_tv(xmlNode *node, Gnt
 	gboolean insert_nl_s = FALSE, insert_nl_e = FALSE;
 
 	if (node == NULL || node->name == NULL || node->type != XML_ELEMENT_NODE)
+	{
+		if (node->type == XML_TEXT_NODE)
+			gnt_text_view_append_text_with_flags(tv, (char *)node->content, flag);
 		return;
+	}
 
 	name = (char*)node->name;
 	if (g_ascii_strcasecmp(name, "b") == 0 ||
@@ -416,6 +421,41 @@ util_parse_html_to_tv(xmlNode *node, Gnt
 		insert_nl_s = TRUE;
 		insert_nl_e = TRUE;
 		flag |= GNT_TEXT_FLAG_BOLD | GNT_TEXT_FLAG_UNDERLINE;
+	} else if (g_ascii_strcasecmp(name, "span") == 0) {
+		xmlChar *style = xmlGetProp(node, (xmlChar *)"style");
+		if (style)
+		{
+			gchar *color, *textdec, *weight;
+			color = purple_markup_get_css_property((char *)style, "color");
+			textdec = purple_markup_get_css_property((char *)style, "text-decoration");
+			weight = purple_markup_get_css_property((char *)style, "font-weight");
+
+			if (color)
+			{
+				/* should use gdk_color_parse or similar */
+				if (!g_ascii_strcasecmp(color, "red"))
+					flag |= gnt_color_pair(GNT_COLOR_RED);
+				else if (!g_ascii_strcasecmp(color, "green"))
+					flag |= gnt_color_pair(GNT_COLOR_GREEN);
+				else if (!g_ascii_strcasecmp(color, "yellow"))
+					flag |= gnt_color_pair(GNT_COLOR_YELLOW);
+				else if (!g_ascii_strcasecmp(color, "blue"))
+					flag |= gnt_color_pair(GNT_COLOR_BLUE);
+				else if (!g_ascii_strcasecmp(color, "magenta"))
+					flag |= gnt_color_pair(GNT_COLOR_MAGENTA);
+				else if (!g_ascii_strcasecmp(color, "cyan"))
+					flag |= gnt_color_pair(GNT_COLOR_CYAN);
+			}
+			if (weight && !g_ascii_strcasecmp(textdec, "bold"))
+				flag |= GNT_TEXT_FLAG_BOLD;
+			if (textdec && !g_ascii_strcasecmp(textdec, "underline"))
+				flag |= GNT_TEXT_FLAG_UNDERLINE;
+
+			g_free(weight);
+			g_free(textdec);
+			g_free(color);
+			xmlFree(style);
+		}
 	} else {
 		/* XXX: Process other possible tags */
 	}
@@ -424,7 +464,7 @@ util_parse_html_to_tv(xmlNode *node, Gnt
 		gnt_text_view_append_text_with_flags(tv, "\n", flag);
 
 	for (ch = node->children; ch; ch = ch->next) {
-		if (ch->type == XML_ELEMENT_NODE) {
+		if (ch->type == XML_ELEMENT_NODE || ch->type == XML_TEXT_NODE) {
 			util_parse_html_to_tv(ch, tv, flag);
 		} else if (ch->type == XML_TEXT_NODE) {
 			content = (char*)xmlNodeGetContent(ch);
@@ -445,15 +485,14 @@ util_parse_html_to_tv(xmlNode *node, Gnt
 }
 #endif
 
-gboolean gnt_util_parse_xhtml_to_textview(const char *string, GntTextView *tv)
+gboolean gnt_util_parse_xhtml_to_textview(const char *string, GntTextView *tv, GntTextFormatFlags flag)
 {
 #ifdef NO_LIBXML
 	return FALSE;
 #else
 	xmlParserCtxtPtr ctxt;
-	xmlDocPtr doc;
+	xmlDocPtr doc = NULL;
 	xmlNodePtr node;
-	GntTextFormatFlags flag = GNT_TEXT_FLAG_NORMAL;
 	gboolean ret = FALSE;
 
 	ctxt = xmlNewParserCtxt();
@@ -464,6 +503,11 @@ gboolean gnt_util_parse_xhtml_to_textvie
 		xmlFreeDoc(doc);
 		ret = TRUE;
 	}
+	else
+	{
+		gnt_text_view_append_text_with_flags(tv, "(HTML parse error) ", flag | GNT_TEXT_FLAG_BOLD);
+		gnt_text_view_append_text_with_flags(tv, string, flag);
+	}
 	xmlFreeParserCtxt(ctxt);
 	return ret;
 #endif
============================================================
--- finch/libgnt/gntutils.h	93b643e27c3571561bb425737a747476494b8ebe
+++ finch/libgnt/gntutils.h	19e752852592c387ffcd394f2ca8d8a47edc3892
@@ -142,7 +142,7 @@ void gnt_util_parse_widgets(const char *
  *
  * @since 2.2.0
  */
-gboolean gnt_util_parse_xhtml_to_textview(const char *string, GntTextView *tv);
+gboolean gnt_util_parse_xhtml_to_textview(const char *string, GntTextView *tv, GntTextFormatFlags flag);
 
 /**
  * Make some keypress activate a button when some key is pressed with 'wid' in focus.
============================================================
--- finch/Makefile.am	059853f082e9aff96218119a09d9e0bf75137cff
+++ finch/Makefile.am	da5ff3c9adfbb6b9eb34599891d275cc360f5939
@@ -25,6 +25,7 @@ finch_SOURCES = \
 	gntft.c \
 	finch.c \
 	gntidle.c \
+	gntimhtml.c \
 	gntlog.c \
 	gntmedia.c \
 	gntnotify.c \
@@ -47,6 +48,7 @@ finch_headers = \
 	gntft.h \
 	finch.h \
 	gntidle.h \
+	gntimhtml.h \
 	gntlog.h \
 	gntmedia.h \
 	gntnotify.h \
============================================================
--- libpurple/plugins/Makefile.am	745b67aa56634bd2b67533d6be2a52ea55f01525
+++ libpurple/plugins/Makefile.am	59cd57ff3a14a15603d108737afcd6cccf254d5a
@@ -42,6 +42,8 @@ statenotify_la_LDFLAGS      = -module -a
 signals_test_la_LDFLAGS		= -module -avoid-version
 simple_la_LDFLAGS			= -module -avoid-version
 statenotify_la_LDFLAGS      = -module -avoid-version
+statelog_la_LDFLAGS      = -module -avoid-version
+syncnotify_la_LDFLAGS      = -module -avoid-version
 
 # this can't be in a conditional otherwise automake 1.4 yells
 dbus_example_la_LDFLAGS     = -module -avoid-version
@@ -58,6 +60,8 @@ plugin_LTLIBRARIES = \
 	offlinemsg.la       \
 	psychic.la          \
 	statenotify.la      \
+	statelog.la      \
+	syncnotify.la      \
 	$(DBUS_LTLIB)
 
 noinst_LTLIBRARIES = \
@@ -89,6 +93,8 @@ statenotify_la_SOURCES      = statenotif
 signals_test_la_SOURCES		= signals-test.c
 simple_la_SOURCES			= simple.c
 statenotify_la_SOURCES      = statenotify.c
+statelog_la_SOURCES      = statelog.c
+syncnotify_la_SOURCES      = syncnotify.c
 
 autoaccept_la_LIBADD        = $(GLIB_LIBS)
 buddynote_la_LIBADD         = $(GLIB_LIBS)
@@ -106,6 +112,8 @@ statenotify_la_LIBADD       = $(GLIB_LIB
 signals_test_la_LIBADD		= $(GLIB_LIBS)
 simple_la_LIBADD			= $(GLIB_LIBS)
 statenotify_la_LIBADD       = $(GLIB_LIBS)
+statelog_la_LIBADD       = $(GLIB_LIBS)
+syncnotify_la_LIBADD       = $(GLIB_LIBS)
 
 if ENABLE_DBUS
 
============================================================
--- finch/libgnt/gntwm.h	98eed7e0a99391a3453fa13d6919a88319231c26
+++ finch/libgnt/gntwm.h	3658861bd0d77c40b3f2fa6d01ba7ddb38e92752
@@ -93,7 +93,7 @@ struct _GntWM
 		*windows,         /* Window-list window */
 		*actions;         /* Action-list window */
 
-	GHashTable *nodes;    /* GntWidget -> GntNode */
+	GList *nodes;    /* GntNode */
 	GHashTable *name_places;    /* window name -> ws*/
 	GHashTable *title_places;    /* window title -> ws */
 
============================================================
--- finch/libgnt/wms/Makefile.am	84e899cd4d3f3b98492da6f4a30b81e73fcb10f5
+++ finch/libgnt/wms/Makefile.am	ba77e27e9a1281f63bf44b7ed6ca81e94490e962
@@ -1,13 +1,14 @@ if PURPLE_AVAILABLE
 wms = irssi.la
 if PURPLE_AVAILABLE
 # These custom wms depend on libpurple
-purple_wms = s.la
+purple_wms = s.la full.la
 else
 purple_wms =
 endif
 
 s_la_LDFLAGS             = -module -avoid-version
 irssi_la_LDFLAGS         = -module -avoid-version
+full_la_LDFLAGS          = -module -avoid-version
 
 plugin_LTLIBRARIES = \
 	$(wms) \
@@ -20,6 +21,11 @@ irssi_la_LIBADD =  \
   $(GLIB_LIBS) \
   ../libgnt.la
 
+full_la_SOURCES = full.c
+full_la_LIBADD =  \
+  $(GLIB_LIBS) \
+  $(top_builddir)/finch/libgnt/libgnt.la
+
 s_la_SOURCES = s.c
 s_la_LIBADD =  \
   $(GLIB_LIBS) \
============================================================
--- finch/libgnt/gntwm.c	b62ec012936d97aa1f1ae69b938963b3f1d01389
+++ finch/libgnt/gntwm.c	37e704e379d3d6b35eb0b8eaf446709d7f690700
@@ -123,14 +123,20 @@ static void
 }
 
 static void
-free_node(gpointer data)
+free_node(GntNode *node)
 {
-	GntNode *node = data;
 	hide_panel(node->panel);
 	del_panel(node->panel);
 	g_free(node);
 }
 
+static GntNode *
+gnt_wm_widget_node(GntWM *wm, GntWidget *widget)
+{
+	/* return g_hash_table_lookup(wm->nodes, widget); */
+	return widget->wmnode;
+}
+
 void
 gnt_wm_copy_win(GntWidget *widget, GntNode *node)
 {
@@ -248,7 +254,7 @@ update_screen(GntWM *wm)
 	if (wm->menu) {
 		GntMenu *top = wm->menu;
 		while (top) {
-			GntNode *node = g_hash_table_lookup(wm->nodes, top);
+			GntNode *node = gnt_wm_widget_node(wm, GNT_WIDGET(top));
 			if (node)
 				top_panel(node->panel);
 			top = top->submenu;
@@ -300,8 +306,10 @@ static void
 }
 
 static void
-refresh_node(GntWidget *widget, GntNode *node, gpointer m)
+refresh_node(GntNode *node, gpointer m)
 {
+	GntWidget *widget = node->me;
+
 	int x, y, w, h;
 	int nw, nh;
 
@@ -409,7 +417,7 @@ gnt_wm_init(GTypeInstance *instance, gpo
 	wm->tagged = NULL;
 	wm->windows = NULL;
 	wm->actions = NULL;
-	wm->nodes = g_hash_table_new_full(g_direct_hash, g_direct_equal, NULL, free_node);
+	wm->nodes = NULL;
 	wm->positions = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);
 	if (gnt_style_get_bool(GNT_STYLE_REMPOS, TRUE))
 		read_window_positions(wm);
@@ -448,7 +456,7 @@ switch_window(GntWM *wm, int direction, 
 			pos = 0;
 		} else
 			wid = g_list_nth_data(wm->cws->list, pos);
-	} while (urgent && !GNT_WIDGET_IS_FLAG_SET(wid, GNT_WIDGET_URGENT) && pos != orgpos);
+	} while ((GNT_WIDGET_IS_FLAG_SET(wid, GNT_WIDGET_SWITCH_SKIP) || (urgent && !GNT_WIDGET_IS_FLAG_SET(wid, GNT_WIDGET_URGENT))) && pos != orgpos);
 
 	gnt_wm_raise_window(wm, wid);
 }
@@ -503,7 +511,7 @@ window_scroll_up(GntBindable *bindable, 
 		return TRUE;
 
 	window = wm->cws->ordered->data;
-	node = g_hash_table_lookup(wm->nodes, window);
+	node = gnt_wm_widget_node(wm, window);
 	if (!node)
 		return TRUE;
 
@@ -527,7 +535,7 @@ window_scroll_down(GntBindable *bindable
 		return TRUE;
 
 	window = wm->cws->ordered->data;
-	node = g_hash_table_lookup(wm->nodes, window);
+	node = gnt_wm_widget_node(wm, window);
 	if (!node)
 		return TRUE;
 
@@ -894,6 +902,7 @@ shift_window(GntWM *wm, GntWidget *widge
 	all = g_list_delete_link(all, list);
 	wm->cws->list = all;
 	gnt_ws_draw_taskbar(wm->cws, FALSE);
+#ifdef BROKENWINCH
 	if (wm->cws->ordered) {
 		GntWidget *w = wm->cws->ordered->data;
 		GntNode *node = g_hash_table_lookup(wm->nodes, w);
@@ -901,6 +910,7 @@ shift_window(GntWM *wm, GntWidget *widge
 		update_panels();
 		doupdate();
 	}
+#endif
 }
 
 static gboolean
@@ -1054,7 +1064,7 @@ window_reverse(GntWidget *win, gboolean 
 	for (i = 0; i < h; i += reverse_char(d, i, 0, set));
 	for (i = 0; i < h; i += reverse_char(d, i, w-1, set));
 
-	gnt_wm_copy_win(win, g_hash_table_lookup(wm->nodes, win));
+	gnt_wm_copy_win(win, gnt_wm_widget_node(wm, win));
 	update_screen(wm);
 }
 
@@ -1123,14 +1133,16 @@ refresh_screen(GntBindable *bindable, GL
 	endwin();
 	refresh();
 
-	g_hash_table_foreach(wm->nodes, (GHFunc)refresh_node, GINT_TO_POINTER(TRUE));
+	g_list_foreach(wm->nodes, (GFunc)refresh_node, GINT_TO_POINTER(TRUE));
 	g_signal_emit(wm, signals[SIG_TERMINAL_REFRESH], 0);
 
+#ifdef BROKENWINCH
 	for (iter = g_list_last(wm->cws->ordered); iter; iter = iter->prev) {
 		GntWidget *w = iter->data;
 		GntNode *node = g_hash_table_lookup(wm->nodes, w);
 		top_panel(node->panel);
 	}
+#endif
 
 	gnt_ws_draw_taskbar(wm->cws, TRUE);
 	update_screen(wm);
@@ -1360,11 +1372,9 @@ static void
 }
 
 static void
-accumulate_windows(gpointer window, gpointer node, gpointer p)
+accumulate_windows(GntNode *node, GList **list)
 {
-	GList *list = *(GList**)p;
-	list = g_list_prepend(list, window);
-	*(GList**)p = list;
+	*list = g_list_prepend(*list, node->me);
 }
 
 static void
@@ -1372,10 +1382,10 @@ gnt_wm_destroy(GObject *obj)
 {
 	GntWM *wm = GNT_WM(obj);
 	GList *list = NULL;
-	g_hash_table_foreach(wm->nodes, accumulate_windows, &list);
+	g_list_foreach(wm->nodes, (GFunc)accumulate_windows, &list);
 	g_list_foreach(list, (GFunc)gnt_widget_destroy, NULL);
 	g_list_free(list);
-	g_hash_table_destroy(wm->nodes);
+	g_list_free(wm->nodes);
 	wm->nodes = NULL;
 
 	while (wm->workspaces) {
@@ -1633,9 +1643,9 @@ gnt_wm_switch_workspace(GntWM *wm, gint 
 		gnt_widget_destroy(wm->_list.window);
 	}
 	ensure_normal_mode(wm);
-	gnt_ws_hide(wm->cws, wm->nodes);
+	gnt_ws_hide(wm->cws);
 	wm->cws = s;
-	gnt_ws_show(wm->cws, wm->nodes);
+	gnt_ws_show(wm->cws);
 
 	gnt_ws_draw_taskbar(wm->cws, TRUE);
 	update_screen(wm);
@@ -1683,7 +1693,7 @@ gnt_wm_widget_move_workspace(GntWM *wm, 
 	GntNode *node;
 	if (!oldw || oldw == neww)
 		return;
-	node = g_hash_table_lookup(wm->nodes, widget);
+	node = gnt_wm_widget_node(wm, widget);
 	if (node && node->ws == neww)
 		return;
 
@@ -1693,9 +1703,9 @@ gnt_wm_widget_move_workspace(GntWM *wm, 
 	gnt_ws_remove_widget(oldw, widget);
 	gnt_ws_add_widget(neww, widget);
 	if (neww == wm->cws) {
-		gnt_ws_widget_show(widget, wm->nodes);
+		gnt_ws_widget_show(widget);
 	} else {
-		gnt_ws_widget_hide(widget, wm->nodes);
+		gnt_ws_widget_hide(widget);
 	}
 }
 
@@ -1807,9 +1817,15 @@ gnt_wm_new_window_real(GntWM *wm, GntWid
 	node->me = widget;
 	node->scroll = 0;
 
-	g_hash_table_replace(wm->nodes, widget, node);
+	if (widget->wmnode)
+	{
+		wm->nodes = g_list_remove(wm->nodes, widget->wmnode);
+		free_node(widget->wmnode);
+	}
+	widget->wmnode = node;
+	wm->nodes = g_list_append(wm->nodes, node);
 
-	refresh_node(widget, node, GINT_TO_POINTER(TRUE));
+	refresh_node(node, GINT_TO_POINTER(TRUE));
 
 	transient = !!GNT_WIDGET_IS_FLAG_SET(node->me, GNT_WIDGET_TRANSIENT);
 
@@ -1864,7 +1880,7 @@ gnt_wm_new_window_real(GntWM *wm, GntWid
 			gnt_widget_set_focus(node->me, FALSE);
 			gnt_widget_set_urgent(node->me);
 			if (wm->cws != ws)
-				gnt_ws_widget_hide(widget, wm->nodes);
+				gnt_ws_widget_hide(widget);
 		}
 	}
 }
@@ -1875,7 +1891,7 @@ void gnt_wm_new_window(GntWM *wm, GntWid
 		widget = widget->parent;
 
 	if (GNT_WIDGET_IS_FLAG_SET(widget, GNT_WIDGET_INVISIBLE) ||
-			g_hash_table_lookup(wm->nodes, widget)) {
+			gnt_wm_widget_node(wm, widget)) {
 		update_screen(wm);
 		return;
 	}
@@ -1920,11 +1936,16 @@ void gnt_wm_window_close(GntWM *wm, GntW
 
 	s = gnt_wm_widget_find_workspace(wm, widget);
 
-	if (g_hash_table_lookup(wm->nodes, widget) == NULL)
+	if (gnt_wm_widget_node(wm, widget) == NULL)
 		return;
 
 	g_signal_emit(wm, signals[SIG_CLOSE_WIN], 0, widget);
-	g_hash_table_remove(wm->nodes, widget);
+	if (widget->wmnode)
+	{
+		wm->nodes = g_list_remove(wm->nodes, widget->wmnode);
+		free_node(widget->wmnode);
+		widget->wmnode = NULL;
+	}
 
 	if (wm->windows) {
 		gnt_tree_remove(GNT_TREE(wm->windows->tree), widget);
@@ -2075,13 +2096,13 @@ gnt_wm_win_resized(GntWM *wm, GntNode *n
 static void
 gnt_wm_win_resized(GntWM *wm, GntNode *node)
 {
-	/*refresh_node(node->me, node, NULL);*/
+	/*refresh_node(node, NULL);*/
 }
 
 static void
 gnt_wm_win_moved(GntWM *wm, GntNode *node)
 {
-	refresh_node(node->me, node, NULL);
+	refresh_node(node, NULL);
 }
 
 void gnt_wm_resize_window(GntWM *wm, GntWidget *widget, int width, int height)
@@ -2092,7 +2113,7 @@ void gnt_wm_resize_window(GntWM *wm, Gnt
 
 	while (widget->parent)
 		widget = widget->parent;
-	node = g_hash_table_lookup(wm->nodes, widget);
+	node = gnt_wm_widget_node(wm, widget);
 	if (!node)
 		return;
 
@@ -2163,7 +2184,7 @@ void gnt_wm_move_window(GntWM *wm, GntWi
 
 	while (widget->parent)
 		widget = widget->parent;
-	node = g_hash_table_lookup(wm->nodes, widget);
+	node = gnt_wm_widget_node(wm, widget);
 	if (!node)
 		return;
 
@@ -2194,7 +2215,7 @@ gnt_wm_give_focus(GntWM *wm, GntWidget *
 static void
 gnt_wm_give_focus(GntWM *wm, GntWidget *widget)
 {
-	GntNode *node = g_hash_table_lookup(wm->nodes, widget);
+	GntNode *node = gnt_wm_widget_node(wm, widget);
 
 	if (!node)
 		return;
@@ -2212,7 +2233,7 @@ gnt_wm_give_focus(GntWM *wm, GntWidget *
 	top_panel(node->panel);
 
 	if (wm->_list.window) {
-		GntNode *nd = g_hash_table_lookup(wm->nodes, wm->_list.window);
+		GntNode *nd = gnt_wm_widget_node(wm, wm->_list.window);
 		top_panel(nd->panel);
 	}
 	gnt_ws_draw_taskbar(wm->cws, FALSE);
@@ -2233,7 +2254,7 @@ void gnt_wm_update_window(GntWM *wm, Gnt
 	}
 
 	ws = gnt_wm_widget_find_workspace(wm, widget);
-	node = g_hash_table_lookup(wm->nodes, widget);
+	node = gnt_wm_widget_node(wm, widget);
 	if (node == NULL) {
 		gnt_wm_new_window(wm, widget);
 	} else
============================================================
--- finch/libgnt/gntws.c	2e65e911d7513fe9f8a4f40a4a6319b1baf00c1a
+++ finch/libgnt/gntws.c	8ed025c72b87bf82a7246b7937b60bb078326a69
@@ -30,10 +30,10 @@ static void
 #include "gntws.h"
 
 static void
-widget_hide(gpointer data, gpointer nodes)
+widget_hide(gpointer data, gpointer unused)
 {
 	GntWidget *widget = GNT_WIDGET(data);
-	GntNode *node = g_hash_table_lookup(nodes, widget);
+	GntNode *node = widget->wmnode;
 	if (GNT_IS_WINDOW(widget))
 		gnt_window_workspace_hiding(GNT_WINDOW(widget));
 	if (node)
@@ -41,13 +41,14 @@ static void
 }
 
 static void
-widget_show(gpointer data, gpointer nodes)
+widget_show(gpointer data)
 {
-	GntNode *node = g_hash_table_lookup(nodes, data);
-	GNT_WIDGET_UNSET_FLAGS(GNT_WIDGET(data), GNT_WIDGET_INVISIBLE);
+	GntWidget *widget = GNT_WIDGET(data);
+	GntNode *node = widget->wmnode;
+	GNT_WIDGET_UNSET_FLAGS(widget, GNT_WIDGET_INVISIBLE);
 	if (node) {
 		show_panel(node->panel);
-		gnt_wm_copy_win(GNT_WIDGET(data), node);
+		gnt_wm_copy_win(widget, node);
 	}
 }
 
@@ -72,15 +73,22 @@ gnt_ws_draw_taskbar(GntWS *ws, gboolean 
 	wbkgdset(taskbar, '\0' | gnt_color_pair(GNT_COLOR_NORMAL));
 	werase(taskbar);
 
-	n = g_list_length(ws->list);
+	for (n = 0, iter = ws->list; iter; iter = iter->next) {
+		if (GNT_WIDGET_IS_FLAG_SET(iter->data, GNT_WIDGET_SWITCH_SKIP))
+			continue;
+		n++;
+	}
 	if (n)
 		width = getmaxx(stdscr) / n;
 
-	for (i = 0, iter = ws->list; iter; iter = iter->next, i++) {
+	for (i = 0, iter = ws->list; iter; iter = iter->next) {
 		GntWidget *w = iter->data;
 		int color;
 		const char *title;
 
+		if (GNT_WIDGET_IS_FLAG_SET(w, GNT_WIDGET_SWITCH_SKIP))
+			continue;
+
 		if (w == ws->ordered->data) {
 			/* This is the current window in focus */
 			color = GNT_COLOR_TITLE;
@@ -99,6 +107,7 @@ gnt_ws_draw_taskbar(GntWS *ws, gboolean 
 		mvwprintw(taskbar, 0, width * i, "%s", title ? C_(title) : "<gnt>");
 		if (i)
 			mvwaddch(taskbar, 0, width *i - 1, ACS_VLINE | A_STANDOUT | gnt_color_pair(GNT_COLOR_NORMAL));
+		i++;
 	}
 	wrefresh(taskbar);
 }
@@ -136,27 +145,27 @@ void
 }
 
 void
-gnt_ws_hide(GntWS *ws, GHashTable *nodes)
+gnt_ws_hide(GntWS *ws)
 {
-	g_list_foreach(ws->ordered, widget_hide, nodes);
+	g_list_foreach(ws->ordered, (GFunc)widget_hide, NULL);
 }
 
-void gnt_ws_widget_hide(GntWidget *widget, GHashTable *nodes)
+void gnt_ws_widget_hide(GntWidget *widget)
 {
-	widget_hide(widget, nodes);
+	widget_hide(widget, NULL);
 }
 
-void gnt_ws_widget_show(GntWidget *widget, GHashTable *nodes)
+void gnt_ws_widget_show(GntWidget *widget)
 {
-	widget_show(widget, nodes);
+	widget_show(widget);
 }
 
 void
-gnt_ws_show(GntWS *ws, GHashTable *nodes)
+gnt_ws_show(GntWS *ws)
 {
 	GList *l;
 	for (l = g_list_last(ws->ordered); l; l = g_list_previous(l))
-		widget_show(l->data, nodes);
+		widget_show(l->data);
 }
 
 GType
============================================================
--- finch/libgnt/gntws.h	94e6e777c0ecc18e512049e146d808c9b162ba8d
+++ finch/libgnt/gntws.h	cfb55d0e60c0264a474aecd893d314671d3ee2b8
@@ -121,21 +121,19 @@ void gnt_ws_remove_widget(GntWS *ws, Gnt
  * Hide a widget in a workspace.
  *
  * @param widget  The widget to hide.
- * @param nodes   A hashtable containing information about the widgets.
  *
  * @since 2.0.0 (gnt), 2.1.0 (pidgin)
  */
-void gnt_ws_widget_hide(GntWidget *widget, GHashTable *nodes);
+void gnt_ws_widget_hide(GntWidget *widget);
 
 /**
  * Show a widget in a workspace.
  *
  * @param widget   The widget to show.
- * @param nodes   A hashtable containing information about the widgets.
  *
  * @since 2.0.0 (gnt), 2.1.0 (pidgin)
  */
-void gnt_ws_widget_show(GntWidget *widget, GHashTable *nodes);
+void gnt_ws_widget_show(GntWidget *widget);
 
 /**
  * Draw the taskbar in a workspace.
@@ -155,7 +153,7 @@ void gnt_ws_draw_taskbar(GntWS *ws, gboo
  *
  * @since 2.0.0 (gnt), 2.1.0 (pidgin)
  */
-void gnt_ws_hide(GntWS *ws, GHashTable *table);
+void gnt_ws_hide(GntWS *ws);
 
 /**
  * Show a workspace.
@@ -165,7 +163,7 @@ void gnt_ws_hide(GntWS *ws, GHashTable *
  *
  * @since 2.0.0 (gnt), 2.1.0 (pidgin)
  */
-void gnt_ws_show(GntWS *ws, GHashTable *table);
+void gnt_ws_show(GntWS *ws);
 
 /**
  * Get the name of a workspace.
============================================================
--- libpurple/media/backend-fs2.h	d0c98270d331a2386413bdc2057c6dac0da72c28
+++ libpurple/media/backend-fs2.h	906b0b66c244bffbb6f9164640bb6ef97f34f14b
@@ -60,6 +60,7 @@ GType purple_media_backend_fs2_get_type(
  * Temporary function in order to be able to test while
  * integrating with PurpleMedia
  */
+#ifdef USE_GSTREAMER
 #include <gst/gst.h>
 GstElement *purple_media_backend_fs2_get_src(
 		PurpleMediaBackendFs2 *self,
@@ -71,6 +72,7 @@ void purple_media_backend_fs2_set_output
 		const gchar *sess_id, double level);
 void purple_media_backend_fs2_set_output_volume(PurpleMediaBackendFs2 *self,
 		const gchar *sess_id, const gchar *who, double level);
+#endif
 /* end tmp */
 #endif /* USE_GSTREAMER */
 
============================================================
--- /dev/null	
+++ finch/gntimhtml.c	ff1312c09d7ffe1a2114ad05a1bb85f3dfb83c57
@@ -0,0 +1,477 @@
+/*
+* @file gntimhtml.c GNT IMHtml
+* @ingroup finch
+*/
+
+/* finch
+*
+* Finch is the legal property of its developers, whose names are too numerous
+* to list here.  Please refer to the COPYRIGHT file distributed with this
+* source distribution.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02111-1301  USA
+*/
+
+#include "gnt.h"
+#include "gnttextview.h"
+#include "gntimhtml.h"
+
+#include "util.h"
+#include <string.h>
+#include <ctype.h>
+
+/******************************************************************************
+* GntIMHtml API
+*****************************************************************************/
+
+/* This could be a separate class, but at present there's no need.
+* Most of the following was copied from pidgin/gtkimhtml */
+
+#define VALID_TAG(x)	if (!g_ascii_strncasecmp (string, x ">", strlen (x ">"))) {	\
+			*tag = g_strndup (string, strlen (x));		\
+			*len = strlen (x) + 1;				\
+			return TRUE;					\
+		}							\
+		(*type)++
+
+#define VALID_OPT_TAG(x) if (!g_ascii_strncasecmp (string, x " ", strlen (x " "))) {	\
+				const gchar *c = string + strlen (x " ");	\
+				gchar e = '"';					\
+				gboolean quote = FALSE;				\
+				while (*c) {					\
+					if (*c == '"' || *c == '\'') {		\
+						if (quote && (*c == e))		\
+							quote = !quote;		\
+						else if (!quote) {		\
+							quote = !quote;		\
+							e = *c;			\
+						}				\
+					} else if (!quote && (*c == '>'))	\
+						break;				\
+					c++;					\
+				}						\
+				if (*c) {					\
+					*tag = g_strndup (string, c - string);	\
+					*len = c - string + 1;			\
+					return TRUE;				\
+				}						\
+			}							\
+			(*type)++
+
+static gboolean
+gnt_imhtml_is_tag (const gchar *string,
+	   gchar      **tag,
+	   gint        *len,
+	   gint        *type)
+{
+	char *close;
+	*type = 1;
+
+	if (!(close = strchr (string, '>')))
+		return FALSE;
+
+	VALID_TAG ("B");
+	VALID_TAG ("BOLD");
+	VALID_TAG ("/B");
+	VALID_TAG ("/BOLD");
+	VALID_TAG ("I");
+	VALID_TAG ("ITALIC");
+	VALID_TAG ("/I");
+	VALID_TAG ("/ITALIC");
+	VALID_TAG ("U");
+	VALID_TAG ("UNDERLINE");
+	VALID_TAG ("/U");
+	VALID_TAG ("/UNDERLINE");
+	VALID_TAG ("S");
+	VALID_TAG ("STRIKE");
+	VALID_TAG ("/S");
+	VALID_TAG ("/STRIKE");
+	VALID_TAG ("SUB");
+	VALID_TAG ("/SUB");
+	VALID_TAG ("SUP");
+	VALID_TAG ("/SUP");
+	VALID_TAG ("PRE");
+	VALID_TAG ("/PRE");
+	VALID_TAG ("TITLE");
+	VALID_TAG ("/TITLE");
+	VALID_TAG ("BR");
+	VALID_TAG ("HR");
+	VALID_TAG ("/FONT");
+	VALID_TAG ("/A");
+	VALID_TAG ("P");
+	VALID_TAG ("/P");
+	VALID_TAG ("H3");
+	VALID_TAG ("/H3");
+	VALID_TAG ("HTML");
+	VALID_TAG ("/HTML");
+	VALID_TAG ("BODY");
+	VALID_TAG ("/BODY");
+	VALID_TAG ("FONT");
+	VALID_TAG ("HEAD");
+	VALID_TAG ("/HEAD");
+	VALID_TAG ("BINARY");
+	VALID_TAG ("/BINARY");
+
+	VALID_OPT_TAG ("HR");
+	VALID_OPT_TAG ("FONT");
+	VALID_OPT_TAG ("BODY");
+	VALID_OPT_TAG ("A");
+	VALID_OPT_TAG ("IMG");
+	VALID_OPT_TAG ("P");
+	VALID_OPT_TAG ("H3");
+	VALID_OPT_TAG ("HTML");
+
+	VALID_TAG ("CITE");
+	VALID_TAG ("/CITE");
+	VALID_TAG ("EM");
+	VALID_TAG ("/EM");
+	VALID_TAG ("STRONG");
+	VALID_TAG ("/STRONG");
+
+	VALID_OPT_TAG ("SPAN");
+	VALID_TAG ("/SPAN");
+	VALID_TAG ("BR/"); /* hack until gtkimhtml handles things better */
+	VALID_TAG ("IMG");
+	VALID_TAG("SPAN");
+	VALID_OPT_TAG("BR");
+
+	if (!g_ascii_strncasecmp(string, "!--", strlen ("!--"))) {
+		gchar *e = strstr (string + strlen("!--"), "-->");
+		if (e) {
+			*len = e - string + strlen ("-->");
+			*tag = g_strndup (string + strlen ("!--"), *len - strlen ("!---->"));
+			return TRUE;
+		}
+	}
+
+	*type = -1;
+	*len = close - string + 1;
+	*tag = g_strndup(string, *len - 1);
+	return TRUE;
+}
+
+static gchar*
+gnt_imhtml_get_html_opt (gchar       *tag,
+		 const gchar *opt)
+{
+	gchar *t = tag;
+	gchar *e, *a;
+	gchar *val;
+	gint len;
+	const gchar *c;
+	GString *ret;
+
+	while (g_ascii_strncasecmp (t, opt, strlen (opt))) {
+		gboolean quote = FALSE;
+		if (*t == '\0') break;
+		while (*t && !((*t == ' ') && !quote)) {
+			if (*t == '\"')
+				quote = ! quote;
+			t++;
+		}
+		while (*t && (*t == ' ')) t++;
+	}
+
+	if (!g_ascii_strncasecmp (t, opt, strlen (opt))) {
+		t += strlen (opt);
+	} else {
+		return NULL;
+	}
+
+	if ((*t == '\"') || (*t == '\'')) {
+		e = a = ++t;
+		while (*e && (*e != *(t - 1))) e++;
+		if  (*e == '\0') {
+			return NULL;
+		} else
+			val = g_strndup(a, e - a);
+	} else {
+		e = a = t;
+		while (*e && !isspace ((gint) *e)) e++;
+		val = g_strndup(a, e - a);
+	}
+
+	ret = g_string_new("");
+	e = val;
+	while(*e) {
+		if((c = purple_markup_unescape_entity(e, &len))) {
+			ret = g_string_append(ret, c);
+			e += len;
+		} else {
+			gunichar uni = g_utf8_get_char(e);
+			ret = g_string_append_unichar(ret, uni);
+			e = g_utf8_next_char(e);
+		}
+	}
+
+	g_free(val);
+
+	return g_string_free(ret, FALSE);
+}
+
+static int gnt_imhtml_fgcolor(const char *color)
+{
+	if (!g_ascii_strcasecmp(color, "red"))
+		return gnt_color_pair(GNT_COLOR_RED);
+	else if (!g_ascii_strcasecmp(color, "green"))
+		return gnt_color_pair(GNT_COLOR_GREEN);
+	else if (!g_ascii_strcasecmp(color, "yellow"))
+		return gnt_color_pair(GNT_COLOR_YELLOW);
+	else if (!g_ascii_strcasecmp(color, "blue"))
+		return gnt_color_pair(GNT_COLOR_BLUE);
+	else if (!g_ascii_strcasecmp(color, "magenta"))
+		return gnt_color_pair(GNT_COLOR_MAGENTA);
+	else if (!g_ascii_strcasecmp(color, "cyan"))
+		return gnt_color_pair(GNT_COLOR_CYAN);
+	else if (!g_ascii_strcasecmp(color, "white"))
+		return gnt_color_pair(GNT_COLOR_WHITE);
+	else if (!g_ascii_strcasecmp(color, "black"))
+		return gnt_color_pair(GNT_COLOR_BLACK);
+	return 0;
+}
+
+void gnt_imhtml_append_markup(GntTextView *view, const char *text, GntTextFormatFlags orig_flags)
+{
+	gchar *ws;
+	gint wpos=0;
+	const gchar *c;
+
+	guint	bold = 0,
+		underline = 0;
+	gchar *href = NULL;
+	gboolean br = FALSE;
+
+	GntTextFormatFlags flags = orig_flags;
+	GSList *fonts = NULL;
+
+	g_return_if_fail (view != NULL);
+	g_return_if_fail (GNT_IS_TEXT_VIEW (view));
+	g_return_if_fail (text != NULL);
+	c = text;
+	ws = g_malloc(strlen(text) + 1);
+	ws[0] = 0;
+
+	#define ADD_TEXT if (wpos) { ws[wpos] = '\0'; gnt_text_view_append_text_with_flags(view, ws, flags); ws[wpos = 0] = '\0'; }
+
+	while (*c)
+	{
+		gchar *tag;
+		gint tlen, type;
+		const gchar *amp;
+		if (*c == '<' && gnt_imhtml_is_tag (c + 1, &tag, &tlen, &type)) {
+				c++;
+				ws[wpos] = '\0';
+				br = FALSE;
+				switch (type)
+				{
+					/* these random numbers are awful */
+					case 1:		/* B */
+					case 2:		/* BOLD */
+					case 54:	/* STRONG */
+					case 52:	/* EM */
+						if (!bold++)
+						{
+							ADD_TEXT;
+							flags |= GNT_TEXT_FLAG_BOLD;
+						}
+						break;
+					case 3:		/* /B */
+					case 4:		/* /BOLD */
+					case 55:	/* /STRONG */
+					case 53:	/* /EM */
+						if (bold && !--bold)
+						{
+							ADD_TEXT;
+							flags &= ~GNT_TEXT_FLAG_BOLD | orig_flags;
+						}
+						break;
+					case 5:		/* I */
+					case 6:		/* ITALIC */
+					case 9:		/* U */
+					case 10:	/* UNDERLINE */
+						ADD_TEXT;
+						underline++;
+						flags ^= GNT_TEXT_FLAG_UNDERLINE;
+						break;
+					case 7:		/* /I */
+					case 8:		/* /ITALIC */
+					case 11:	/* /U */
+					case 12:	/* /UNDERLINE */
+						if (underline)
+						{
+							ADD_TEXT;
+							underline--;
+							flags ^= GNT_TEXT_FLAG_UNDERLINE;
+						}
+						break;
+					case 17:	/* SUB */
+						ws[wpos++] = '_';
+						break;
+					case 19:	/* SUP */
+						ws[wpos++] = '^';
+						break;
+					case 25:	/* BR */
+					case 58:	/* BR/ */
+					case 61:	/* BR (opt) */
+					case 26:        /* HR */
+					case 42:        /* HR (opt) */
+						ws[wpos++] = '\n';
+						br = TRUE;
+						break;
+					case 37:	/* FONT */
+						fonts = g_slist_prepend(fonts, GINT_TO_POINTER(flags));
+						break;
+					case 43:	/* FONT (opt) */
+						fonts = g_slist_prepend(fonts, GINT_TO_POINTER(flags));
+						{
+							gchar *color;
+							color = gnt_imhtml_get_html_opt (tag, "COLOR=");
+
+							if (color)
+							{
+								ADD_TEXT;
+								flags &= ~A_COLOR;
+								flags |= gnt_imhtml_fgcolor(color);
+								g_free(color);
+							}
+						}
+						break;
+					case 27:	/* /FONT */
+						if (fonts)
+						{
+							ADD_TEXT;
+							flags &= ~A_COLOR;
+							flags |= GPOINTER_TO_INT(fonts->data) & A_COLOR;
+							fonts = g_slist_remove (fonts, fonts->data);
+
+						}
+						break;
+					case 45:	/* A (opt) */
+						ADD_TEXT;
+						if (href)
+							g_free(href);
+						href = gnt_imhtml_get_html_opt(tag, "HREF=");
+						flags ^= GNT_TEXT_FLAG_UNDERLINE;
+						break;
+					case 28:        /* /A    */
+						ADD_TEXT;
+						flags ^= GNT_TEXT_FLAG_UNDERLINE;
+						if (href)
+						{
+							// ws[wpos++] = ' ';
+							ws[wpos++] = '[';
+							strcpy(&ws[wpos], href);
+							wpos += strlen(href);
+							ws[wpos++] = ']';
+							g_free(href);
+							href = NULL;
+						}
+						break;
+					case 47:	/* P (opt) */
+					case 48:	/* H3 (opt) */
+					case 49:	/* HTML (opt) */
+					case 50:	/* CITE */
+					case 51:	/* /CITE */
+					case 56:	/* SPAN (opt) */
+						fonts = g_slist_prepend(fonts, GINT_TO_POINTER(flags));
+						{
+							gchar *style, *color = NULL, *textdec = NULL, *weight = NULL;
+							style = gnt_imhtml_get_html_opt (tag, "style=");
+
+							if (style)
+							{
+								color = purple_markup_get_css_property (style, "color");
+								textdec = purple_markup_get_css_property (style, "text-decoration");
+								weight = purple_markup_get_css_property (style, "font-weight");
+							}
+
+							if (color)
+							{
+								ADD_TEXT;
+								flags &= ~A_COLOR;
+								flags |= gnt_imhtml_fgcolor(color);
+								g_free(color);
+							}
+							if (textdec)
+							{
+								if (!g_ascii_strcasecmp(textdec, "underline"))
+								{
+									ADD_TEXT;
+									flags ^= GNT_TEXT_FLAG_UNDERLINE;
+								}
+								g_free(textdec);
+							}
+							if (weight)
+							{
+								if (!g_ascii_strcasecmp(weight, "normal"))
+								{
+									flags &= ~GNT_TEXT_FLAG_BOLD;
+									flags |= orig_flags & GNT_TEXT_FLAG_BOLD;
+								}
+								else if (!g_ascii_strcasecmp(weight, "bold") || !g_ascii_strcasecmp(weight, "bolder"))
+									flags |= GNT_TEXT_FLAG_BOLD;
+								else if (!g_ascii_strcasecmp(weight, "lighter"))
+									flags &= ~GNT_TEXT_FLAG_BOLD;
+								g_free(weight);
+							}
+
+							g_free(style);
+						}
+						break;
+					case 57:	/* /SPAN */
+						if (fonts)
+						{
+							ADD_TEXT;
+							flags = GPOINTER_TO_INT(fonts->data);
+							fonts = g_slist_remove(fonts, fonts->data);
+						}
+						break;
+					case 62:	/* comment */
+						ADD_TEXT;
+						break;
+					default:
+						break;
+				}
+				c += tlen;
+				g_free(tag); /* This was allocated back in VALID_TAG() */
+			} else if (*c == '&' && (amp = purple_markup_unescape_entity(c, &tlen))) {
+				br = FALSE;
+				while(*amp) {
+					ws [wpos++] = *amp++;
+				}
+				c += tlen;
+			} else if (*c == '\n') {
+				if (!br) {  /* Don't insert a space immediately after an HTML break */
+					/* A newline is defined by HTML as whitespace, which means we have to replace it with a word boundary.
+					 * word breaks vary depending on the language used, so the correct thing to do is to use Pango to determine
+					 * what language this is, determine the proper word boundary to use, and insert that. I'm just going to insert
+					 * a space instead.  What are the non-English speakers going to do?  Complain in a language I'll understand?
+					 * Bu-wahaha! */
+					ws[wpos++] = ' ';
+				}
+				c++;
+			} else {
+				br = FALSE;
+				ws [wpos++] = *c++;
+			}
+		}
+		ADD_TEXT;
+
+		while (fonts)
+			fonts = g_slist_remove(fonts, fonts->data);
+
+		g_free(ws);
+}
+
============================================================
--- /dev/null	
+++ finch/gntimhtml.h	0c5b961854c6265801f7efa7d9d6de30084d9e7c
@@ -0,0 +1,48 @@
+/**
+ * @file gntimhtml.h GNT IM/HTML rendering component
+ * @ingroup finch
+ */
+
+/* finch
+ *
+ * Finch is the legal property of its developers, whose names are too numerous
+ * to list here.  Please refer to the COPYRIGHT file distributed with this
+ * source distribution.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02111-1301  USA
+ */
+#ifndef _GNT_IMHTML_H
+#define _GNT_IMHTML_H
+
+#include <gnt.h>
+#include "gnttextview.h"
+
+/**************************************************************************
+ * @name GNT IM/HTML rendering component API
+ **************************************************************************/
+/*@{*/
+
+/**
+ * Inserts HTML formatted text to a GNT Textview.
+ *
+ * @param imhtml  The GNT Textview.
+ * @param text    The formatted text to append.
+ * @param flags  The text-flags to apply to the new text.
+ */
+void gnt_imhtml_append_markup(GntTextView *view, const char *text, GntTextFormatFlags flags);
+
+/*@}*/
+
+#endif /* _GNT_IMHTML_H */
============================================================
--- /dev/null	
+++ finch/libgnt/wms/full.c	cf9a87b273887935415faba54ac9cc61d8f6ccca
@@ -0,0 +1,196 @@
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+
+#include "debug.h"
+#include "gnt.h"
+#include "gntbox.h"
+#include "gntmenu.h"
+#include "gntstyle.h"
+#include "gntwm.h"
+#include "gntwindow.h"
+#include "gntlabel.h"
+
+#include "blist.h"
+
+#define TYPE_FULL				(full_get_gtype())
+
+typedef struct _Full
+{
+	GntWM inherit;
+
+	gboolean borders;
+	int blistwidth;
+} Full;
+
+typedef struct _FullClass
+{
+	GntWMClass inherit;
+} FullClass;
+
+GType full_get_gtype(void);
+void gntwm_init(GntWM **wm);
+
+static void (*org_new_window)(GntWM *wm, GntWidget *win);
+
+static void
+draw_line_separators(Full *full)
+{
+	/*
+	wclear(stdscr);
+	if (full->blistwidth >= 0)
+		mvwvline(stdscr, 0, getmaxx(stdscr) - full->blistwidth - 1,
+				ACS_VLINE | COLOR_PAIR(GNT_COLOR_NORMAL), getmaxy(stdscr) - 1);
+	*/
+}
+
+static gboolean
+is_blist(GntWidget *win)
+{
+	const char *name = gnt_widget_get_name(win);
+	if (name && strcmp(name, "buddylist") == 0)
+		return TRUE;
+	return FALSE;
+}
+
+static void
+relocate_win(Full *full, GntWidget *win, int x, int y, int w, int h)
+{
+	GntNode *node = win->wmnode; // g_hash_table_lookup(GNT_WM(full)->nodes, win);
+	// purple_debug(PURPLE_DEBUG_INFO, "full", "relocate %s %p %p %d,%d,%d,%d\n", gnt_widget_get_name(win), win, win->parent, x,y,w,h);
+	if (!full->borders && !GNT_WIDGET_IS_FLAG_SET(win, GNT_WIDGET_NO_BORDER))
+	{
+		GNT_WIDGET_SET_FLAGS(win, GNT_WIDGET_NO_BORDER | GNT_WIDGET_NO_SHADOW);
+		w += 2; h += 2;
+	}
+	if (node)
+	{
+		hide_panel(node->panel);
+	}
+	gnt_widget_set_size(win, w, h);
+	gnt_widget_set_position(win, x, y);
+	if (node)
+	{
+		wresize(node->window, h, w);
+		replace_panel(node->panel, node->window);
+		show_panel(node->panel);
+		move_panel(node->panel, y, x);
+	}
+}
+
+static void
+place_win(Full *full, GntWidget *win)
+{
+	if (is_blist(win))
+	{
+		if (full->blistwidth <= 0)
+			gnt_widget_get_size(win, &full->blistwidth, NULL);
+		relocate_win(full, win, getmaxx(stdscr)-full->blistwidth-full->borders, 0, full->blistwidth+full->borders, getmaxy(stdscr)-1);
+	}
+	else if (!GNT_IS_MENU(win) && !GNT_WIDGET_IS_FLAG_SET(win, GNT_WIDGET_TRANSIENT)) {
+		relocate_win(full, win, 0, 0, getmaxx(stdscr) - full->blistwidth, getmaxy(stdscr)-1);
+	}
+}
+
+static void
+full_new_window(GntWM *wm, GntWidget *win)
+{
+	Full *full = (Full *)wm;
+	if (is_blist(win))
+		GNT_WIDGET_SET_FLAGS(win, GNT_WIDGET_SWITCH_SKIP);
+	place_win(full, win);
+	org_new_window(wm, win);
+}
+
+static void
+full_terminal_refresh(GntWM *wm)
+{
+	Full *full = (Full *)wm;
+	GList *iter;
+	for (iter = wm->cws->list; iter; iter = iter->next) {
+		GntWidget *win = GNT_WIDGET(iter->data);
+		place_win(full, win);
+	}
+
+	draw_line_separators(full);
+	// update_panels();
+	// doupdate();
+}
+
+static gboolean
+focus_blist(GntBindable *bindable, GList *null)
+{
+	purple_blist_show();
+	return TRUE;
+}
+
+static gboolean
+return_false(GntWM *wm, GntWidget *w, int *a, int *b)
+{
+	// purple_debug(PURPLE_DEBUG_INFO, "full", "confirm %s %p %p %d,%d\n", gnt_widget_get_name(w), w, w->parent, *a,*b);
+	return FALSE;
+}
+
+static void
+full_class_init(FullClass *klass)
+{
+	GntWMClass *pclass = GNT_WM_CLASS(klass);
+
+	org_new_window = pclass->new_window;
+
+	pclass->new_window = full_new_window;
+	//pclass->window_resized = full_window_resized;
+	//pclass->close_window = full_close_window;
+	pclass->window_resize_confirm = return_false;
+	pclass->window_move_confirm = return_false;
+	pclass->terminal_refresh = full_terminal_refresh;
+
+	gnt_bindable_class_register_action(GNT_BINDABLE_CLASS(klass), "window-blist", focus_blist, "\033" "b", NULL);
+
+	gnt_style_read_actions(G_OBJECT_CLASS_TYPE(klass), GNT_BINDABLE_CLASS(klass));
+	GNTDEBUG;
+}
+
+void gntwm_init(GntWM **wm)
+{
+	char *style = NULL;
+	Full *full;
+
+	full = g_object_new(TYPE_FULL, NULL);
+	*wm = GNT_WM(full);
+
+	style = gnt_style_get_from_name("full", "blist-width");
+	full->blistwidth = style ? atoi(style) : 0;
+	g_free(style);
+
+	style = gnt_style_get_from_name("full", "borders");
+	full->borders = gnt_style_parse_bool(style);
+	g_free(style);
+}
+
+GType full_get_gtype(void)
+{
+	static GType type = 0;
+
+	if(type == 0) {
+		static const GTypeInfo info = {
+			sizeof(FullClass),
+			NULL,           /* base_init		*/
+			NULL,           /* base_finalize	*/
+			(GClassInitFunc)full_class_init,
+			NULL,
+			NULL,           /* class_data		*/
+			sizeof(Full),
+			0,              /* n_preallocs		*/
+			NULL,	        /* instance_init	*/
+			NULL
+		};
+
+		type = g_type_register_static(GNT_TYPE_WM,
+		                              "GntFull",
+		                              &info, 0);
+	}
+
+	return type;
+}
+
============================================================
--- /dev/null	
+++ libpurple/plugins/statelog.c	fa3ef8c31cbe2abf19d0608b9d7ba30a640493e2
@@ -0,0 +1,336 @@
+#include "internal.h"
+#include "debug.h"
+#include "plugin.h"
+#include "version.h"
+#include "blist.h"
+
+/** Plugin id : type-author-name (to guarantee uniqueness) */
+#define STATELOG_PLUGIN_ID "core-dylex-statelog"
+
+struct BuddyState {
+	time_t conn, idle;
+	gboolean away;
+	char *msg;
+};
+
+static GHashTable *buddy_states;
+
+static void buddy_state_free(struct BuddyState *bs)
+{
+	if (bs->msg)
+		g_free(bs->msg);
+	g_free(bs);
+}
+
+static char *msg_dup(const char *msg)
+{
+	gsize n = strlen(msg);
+	if (!strncasecmp(msg, "<html>", 6))
+	{
+		msg += 6;
+		n -= 6;
+	}
+	if (!strncasecmp(msg, "<body>", 6))
+	{
+		msg += 6;
+		n -= 6;
+	}
+	if (n >= 7 && !strncasecmp(msg+n-7, "</html>", 7))
+	{
+		n -= 7;
+	}
+	if (n >= 7 && !strncasecmp(msg+n-7, "</body>", 7))
+	{
+		n -= 7;
+	}
+	return g_strndup(msg, n);
+}
+
+static void
+update_state(PurpleBuddy *buddy) // , time_t when, const char *status, const char *msg)
+{
+	struct BuddyState *curr;
+	const char *who;
+	char *escaped;
+	const PurplePresence *presence;
+	const PurpleStatus *status;
+	time_t when = 0, conn, idle;
+	const char *msg;
+	gboolean away;
+	gboolean changed = FALSE;
+	GString *buf;
+
+	who = purple_buddy_get_alias(buddy);
+	escaped = g_markup_escape_text(who, -1);
+	buf = g_string_new(escaped);
+	g_free(escaped);
+
+	curr = g_hash_table_lookup(buddy_states, buddy);
+	if (!curr)
+	{
+		curr = g_new0(struct BuddyState, 1);
+		g_hash_table_insert(buddy_states, buddy, curr);
+	}
+
+	presence = purple_buddy_get_presence(buddy);
+	status = purple_presence_get_active_status(presence);
+
+	if (purple_presence_is_online(presence))
+	{
+		if (!(conn = purple_presence_get_login_time(presence)))
+			if (!(conn = curr->conn))
+				time(&conn);
+	}
+	else
+		conn = 0;
+	if (purple_prefs_get_bool("/plugins/core/statelog/log_conn")
+			&& conn != curr->conn)
+	{
+		if (conn)
+		{
+			when = conn;
+			g_string_append(buf, " <font color=\"yellow\">signon</font>");
+		}
+		else
+			g_string_append(buf, " <font color=\"red\">signoff</font>");
+		curr->conn = conn;
+		changed = TRUE;
+	}
+
+	if (purple_presence_is_idle(presence))
+	{
+		idle = purple_presence_get_idle_time(presence);
+		if (!idle) time(&idle);
+	}
+	else
+		idle = 0;
+	if (conn && purple_prefs_get_bool("/plugins/core/statelog/log_idle")
+			&& idle != curr->idle)
+	{
+		if (idle)
+		{
+			if (!when) when = idle;
+			g_string_append(buf, " <font color=\"cyan\">idle</font>");
+		}
+		else
+			g_string_append(buf, " unidle");
+		curr->idle = idle;
+		changed = TRUE;
+	}
+
+	if (conn && purple_prefs_get_bool("/plugins/core/statelog/log_away")
+			&& (away = !purple_status_is_available(status)) != curr->away)
+	{
+		if (away)
+			g_string_append_printf(buf, " <font color=\"green\">%s</font>", purple_status_get_name(status) ?: "away");
+		else
+			g_string_append_printf(buf, " %s", purple_status_get_name(status) ?: "back");
+		curr->away = away;
+		changed = TRUE;
+	}
+
+	if (purple_prefs_get_bool("/plugins/core/statelog/log_msg") 
+			&& (msg = purple_status_get_attr_string(status, "message"))
+			&& (!curr->msg || strcmp(msg, curr->msg)))
+	{
+		/* XXX clear if msg == NULL? */
+		gchar *cmsg = msg_dup(msg);
+		if (!curr->msg || strcmp(cmsg, curr->msg))
+		{
+			purple_debug_info("statelog", "changing msg from '%s' to '%s'\n", curr->msg, cmsg);
+			g_string_append_printf(buf, ": %s", cmsg);
+			if (curr->msg) g_free(curr->msg);
+			curr->msg = cmsg;
+			changed = TRUE;
+		}
+		else
+		{
+			g_free(cmsg);
+		}
+	}
+
+	if (!changed)
+	{
+		g_string_free(buf, TRUE);
+		return;
+	}
+
+	if (!when) time(&when);
+
+	if (purple_prefs_get_bool("/plugins/core/statelog/to_conv")) {
+		PurpleConversation *conv = purple_find_conversation_with_account(PURPLE_CONV_TYPE_IM, buddy->name, buddy->account);
+		if (conv && conv->type == PURPLE_CONV_TYPE_IM)
+			purple_conv_im_write(conv->u.im, NULL, buf->str, PURPLE_MESSAGE_SYSTEM | PURPLE_MESSAGE_ACTIVE_ONLY | PURPLE_MESSAGE_NO_LOG, when);
+	}
+
+	if (purple_prefs_get_bool("/plugins/core/statelog/collapsed") || !purple_blist_node_get_bool(&purple_buddy_get_group(buddy)->node, "collapsed"))
+	{
+		if (purple_prefs_get_bool("/plugins/core/statelog/to_acct")) {
+			PurpleLog *log = purple_account_get_log(buddy->account, FALSE);
+			if (log)
+				purple_log_write(log, PURPLE_MESSAGE_SYSTEM, who, when, buf->str);
+		}
+
+		if (purple_prefs_get_bool("/plugins/core/statelog/to_self")) {
+			PurpleConversation *conv = purple_find_conversation_with_account(PURPLE_CONV_TYPE_MISC, "state", buddy->account);
+			if (!conv)
+				conv = purple_conversation_new(PURPLE_CONV_TYPE_MISC, buddy->account, "state");
+			if (conv)
+				purple_conversation_write(conv, who, buf->str, PURPLE_MESSAGE_SYSTEM | PURPLE_MESSAGE_ACTIVE_ONLY, when);
+		}
+	}
+
+	g_string_free(buf, TRUE);
+}
+
+static void
+buddy_status_changed_cb(PurpleBuddy *buddy, PurpleStatus *old_status,
+                        PurpleStatus *status, void *data)
+{
+	update_state(buddy);
+}
+
+static void
+buddy_idle_changed_cb(PurpleBuddy *buddy, gboolean old_idle, gboolean idle,
+                      void *data)
+{
+	update_state(buddy);
+}
+
+static void
+buddy_signon_cb(PurpleBuddy *buddy, void *data)
+{
+	update_state(buddy);
+}
+
+static void
+buddy_signoff_cb(PurpleBuddy *buddy, void *data)
+{
+	update_state(buddy);
+}
+
+static PurplePluginPrefFrame *
+get_plugin_pref_frame(PurplePlugin *plugin)
+{
+	PurplePluginPrefFrame *frame;
+	PurplePluginPref *ppref;
+
+	frame = purple_plugin_pref_frame_new();
+
+	ppref = purple_plugin_pref_new_with_label(_("Log To"));
+	purple_plugin_pref_frame_add(frame, ppref);
+
+	ppref = purple_plugin_pref_new_with_name_and_label("/plugins/core/statelog/to_conv", _("_Buddy Conversation"));
+	purple_plugin_pref_frame_add(frame, ppref);
+
+	ppref = purple_plugin_pref_new_with_name_and_label("/plugins/core/statelog/to_acct", _("Account _Log"));
+	purple_plugin_pref_frame_add(frame, ppref);
+
+	ppref = purple_plugin_pref_new_with_name_and_label("/plugins/core/statelog/to_self", _("_State Conversation"));
+	purple_plugin_pref_frame_add(frame, ppref);
+
+	ppref = purple_plugin_pref_new_with_label(_("Log When"));
+	purple_plugin_pref_frame_add(frame, ppref);
+
+	ppref = purple_plugin_pref_new_with_name_and_label("/plugins/core/statelog/log_away", _("Buddy Goes _Away"));
+	purple_plugin_pref_frame_add(frame, ppref);
+
+	ppref = purple_plugin_pref_new_with_name_and_label("/plugins/core/statelog/log_idle", _("Buddy Goes _Idle"));
+	purple_plugin_pref_frame_add(frame, ppref);
+
+	ppref = purple_plugin_pref_new_with_name_and_label("/plugins/core/statelog/log_conn", _("Buddy _Connects/Disconnects"));
+	purple_plugin_pref_frame_add(frame, ppref);
+
+	ppref = purple_plugin_pref_new_with_name_and_label("/plugins/core/statelog/collapsed", _("Buddy in Collapsed _Group"));
+	purple_plugin_pref_frame_add(frame, ppref);
+
+	ppref = purple_plugin_pref_new_with_name_and_label("/plugins/core/statelog/log_msg", _("Include Status _Message"));
+	purple_plugin_pref_frame_add(frame, ppref);
+
+	return frame;
+}
+
+static gboolean
+plugin_load(PurplePlugin *plugin)
+{
+	void *blist_handle = purple_blist_get_handle();
+
+	buddy_states = g_hash_table_new_full(NULL, NULL, NULL, (GDestroyNotify)buddy_state_free);
+
+	purple_signal_connect(blist_handle, "buddy-status-changed", plugin,
+	                    PURPLE_CALLBACK(buddy_status_changed_cb), NULL);
+	purple_signal_connect(blist_handle, "buddy-idle-changed", plugin,
+	                    PURPLE_CALLBACK(buddy_idle_changed_cb), NULL);
+	purple_signal_connect(blist_handle, "buddy-signed-on", plugin,
+	                    PURPLE_CALLBACK(buddy_signon_cb), NULL);
+	purple_signal_connect(blist_handle, "buddy-signed-off", plugin,
+	                    PURPLE_CALLBACK(buddy_signoff_cb), NULL);
+
+	purple_debug_info("statelog", "statelog plugin loaded.\n");
+
+	return TRUE;
+}
+
+static gboolean
+plugin_unload(PurplePlugin *plugin)
+{
+	purple_debug_info("statelog", "statelog plugin unloaded.\n");
+
+	g_hash_table_destroy(buddy_states);
+
+	return TRUE;
+}
+
+static PurplePluginUiInfo prefs_info =
+{
+	get_plugin_pref_frame,
+	0,   /* page_num (Reserved) */
+	NULL /* frame (Reserved) */
+};
+
+static PurplePluginInfo info =
+{
+	PURPLE_PLUGIN_MAGIC,
+	PURPLE_MAJOR_VERSION,
+	PURPLE_MINOR_VERSION,
+	PURPLE_PLUGIN_STANDARD,                             /**< type           */
+	NULL,                                             /**< ui_requirement */
+	0,                                                /**< flags          */
+	NULL,                                             /**< dependencies   */
+	PURPLE_PRIORITY_DEFAULT,                            /**< priority       */
+
+	STATELOG_PLUGIN_ID,                                 /**< id             */
+	N_("State Logger"),                              /**< name           */
+	DISPLAY_VERSION,                                  /**< version        */
+	                                                  /**  summary        */
+	N_("Logs presence changes and away messages of buddies."),
+	                                                  /**  description    */
+	N_("Logs presence changes and away messages of buddies.  Based on statenotify."),
+	"Dylan Simon <dylan@dylex.net>",        /**< author         */
+	NULL,                                     /**< homepage       */
+
+	plugin_load,                                      /**< load           */
+	plugin_unload,                                    /**< unload         */
+	NULL,                                             /**< destroy        */
+
+	NULL,                                             /**< ui_info        */
+	NULL,                                             /**< extra_info     */
+	&prefs_info,
+	NULL
+};
+
+static void
+init_plugin(PurplePlugin *plugin)
+{
+	purple_prefs_add_none("/plugins/core/statelog");
+	purple_prefs_add_bool("/plugins/core/statelog/to_conv", TRUE);
+	purple_prefs_add_bool("/plugins/core/statelog/to_acct", FALSE);
+	purple_prefs_add_bool("/plugins/core/statelog/to_self", FALSE);
+	purple_prefs_add_bool("/plugins/core/statelog/log_away", TRUE);
+	purple_prefs_add_bool("/plugins/core/statelog/log_idle", FALSE);
+	purple_prefs_add_bool("/plugins/core/statelog/log_conn", TRUE);
+	purple_prefs_add_bool("/plugins/core/statelog/log_msg", FALSE);
+	purple_prefs_add_bool("/plugins/core/statelog/collapsed", FALSE);
+}
+
+PURPLE_INIT_PLUGIN(statelog, init_plugin, info)
============================================================
--- /dev/null	
+++ libpurple/plugins/syncnotify.c	525b2b218d22dac8f58ecf8a162eed40b921b60f
@@ -0,0 +1,95 @@
+#include "internal.h"
+#include "debug.h"
+#include "plugin.h"
+#include "version.h"
+#include "blist.h"
+
+/** Plugin id : type-author-name (to guarantee uniqueness) */
+#define NOTIFY_PLUGIN_ID "core-dylex-syncnotify"
+
+#define PATH "/home/dylan/.sync-notify"
+static const struct sockaddr_un ADDR = {
+	AF_UNIX,
+	"/home/dylan/.sync-notify"
+};
+
+static void
+conversation_created_cb(PurpleConversation *conv, void *data)
+{
+	if (conv->logs == NULL)
+		return;
+	PurpleLog *log = conv->logs->data;
+	if (log == NULL)
+		return;
+	int s = socket(AF_UNIX, SOCK_DGRAM, 0);
+	if (s < 0)
+	{
+		purple_debug_warning("syncnotify", "socket: %m\n");
+		return;
+	}
+	char *dir = purple_log_get_log_dir(log->type, log->name, log->account);
+	const struct tm *tm = localtime(&log->time);
+	const char *tz = purple_escape_filename(purple_utf8_strftime("%Z", tm));
+	const char *date = purple_utf8_strftime("%Y-%m-%d.%H%M%S%z", tm);
+	char *filename = g_strdup_printf("%s%s.html", date, tz);
+	const char *path = g_build_filename(dir, filename, NULL);
+	g_free(dir);
+	g_free(filename);
+	ssize_t r = sendto(s, path, strlen(path), 0, &ADDR, SUN_LEN(&ADDR)+1);
+	if (r < 0 && errno != ENOENT && errno != ECONNREFUSED)
+		purple_debug_warning("syncnotify", "sendto: %m\n");
+	close(s);
+}
+
+static gboolean
+plugin_load(PurplePlugin *plugin)
+{
+	purple_signal_connect(purple_conversations_get_handle(), "conversation-created", plugin,
+	                    PURPLE_CALLBACK(conversation_created_cb), NULL);
+
+	return TRUE;
+}
+
+static gboolean
+plugin_unload(PurplePlugin *plugin)
+{
+	return TRUE;
+}
+
+static PurplePluginInfo info =
+{
+	PURPLE_PLUGIN_MAGIC,
+	PURPLE_MAJOR_VERSION,
+	PURPLE_MINOR_VERSION,
+	PURPLE_PLUGIN_STANDARD,                             /**< type           */
+	NULL,                                             /**< ui_requirement */
+	0,                                                /**< flags          */
+	NULL,                                             /**< dependencies   */
+	PURPLE_PRIORITY_DEFAULT,                            /**< priority       */
+
+	NOTIFY_PLUGIN_ID,                                 /**< id             */
+	N_("Dylex Notifier"),                              /**< name           */
+	DISPLAY_VERSION,                                  /**< version        */
+	                                                  /**  summary        */
+	N_("Pushes relevant event notifications."),
+	                                                  /**  description    */
+	N_("Pushes relevant event notifications."),
+	"Dylan Simon <dylan@dylex.net>",        /**< author         */
+	NULL,                                     /**< homepage       */
+
+	plugin_load,                                      /**< load           */
+	plugin_unload,                                    /**< unload         */
+	NULL,                                             /**< destroy        */
+
+	NULL,                                             /**< ui_info        */
+	NULL,                                             /**< extra_info     */
+	NULL,
+	NULL
+};
+
+static void
+init_plugin(PurplePlugin *plugin)
+{
+}
+
+PURPLE_INIT_PLUGIN(notify, init_plugin, info)
